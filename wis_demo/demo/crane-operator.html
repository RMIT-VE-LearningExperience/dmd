<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Crane Operator â€” Construction Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Oswald:wght@500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a1a2e;
    overflow: hidden;
    font-family: 'Chakra Petch', monospace;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
  }

  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }

  /* Start Screen */
  #startScreen {
    position: fixed;
    inset: 0;
    background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100;
    transition: opacity 0.8s ease, transform 0.8s ease;
  }

  #startScreen.hiding {
    opacity: 0;
    transform: scale(1.1);
    pointer-events: none;
  }

  #startScreen h1 {
    font-family: 'Oswald', sans-serif;
    font-size: clamp(2rem, 6vw, 4.5rem);
    color: #f5a623;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    text-shadow: 0 0 40px rgba(245,166,35,0.4), 0 4px 0 #c47d10;
    margin-bottom: 0.3em;
  }

  #startScreen p {
    color: #8888aa;
    font-size: clamp(0.8rem, 2vw, 1.1rem);
    margin-bottom: 2em;
    letter-spacing: 0.05em;
  }

  #startBtn {
    font-family: 'Oswald', sans-serif;
    font-size: 1.4rem;
    padding: 0.8em 3em;
    background: linear-gradient(180deg, #f5a623, #d4891a);
    color: #1a1a2e;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    font-weight: 700;
    box-shadow: 0 6px 0 #a06510, 0 8px 30px rgba(245,166,35,0.3);
    transition: all 0.15s;
  }

  #startBtn:hover { transform: translateY(-2px); box-shadow: 0 8px 0 #a06510, 0 12px 40px rgba(245,166,35,0.4); }
  #startBtn:active { transform: translateY(4px); box-shadow: 0 2px 0 #a06510; }

  /* HUD */
  #hud {
    position: fixed;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    gap: 20px;
    z-index: 50;
    align-items: center;
  }

  .hud-box {
    background: rgba(15,12,41,0.85);
    border: 1px solid rgba(245,166,35,0.3);
    border-radius: 6px;
    padding: 6px 16px;
    color: #f5a623;
    font-size: 0.85rem;
    font-weight: 600;
    letter-spacing: 0.05em;
    backdrop-filter: blur(8px);
    white-space: nowrap;
  }

  #statusText {
    color: #77dd77;
  }

  /* Controls */
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    z-index: 50;
    gap: 12px;
    align-items: end;
  }

  .ctrl-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  .ctrl-row {
    display: flex;
    gap: 6px;
  }

  .ctrl-btn {
    width: 56px;
    height: 56px;
    border-radius: 10px;
    border: 2px solid rgba(245,166,35,0.5);
    background: rgba(15,12,41,0.8);
    color: #f5a623;
    font-size: 1.4rem;
    font-family: 'Chakra Petch', monospace;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(8px);
    transition: all 0.1s;
    -webkit-tap-highlight-color: transparent;
  }

  .ctrl-btn:active, .ctrl-btn.active {
    background: rgba(245,166,35,0.3);
    border-color: #f5a623;
    transform: scale(0.93);
  }

  .ctrl-btn.hook-btn {
    width: 80px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    line-height: 1.2;
  }

  .ctrl-btn.hook-btn.hooked {
    background: rgba(245,60,60,0.3);
    border-color: #f55;
    color: #f55;
  }

  /* End Screen (win & game over) */
  #endScreen {
    position: fixed;
    inset: 0;
    background: rgba(15,12,41,0.92);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
  }

  #endScreen h2 {
    font-family: 'Oswald', sans-serif;
    font-size: 3rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    margin-bottom: 0.5em;
  }

  #endScreen h2.win-title {
    color: #77dd77;
    text-shadow: 0 0 40px rgba(119,221,119,0.5);
  }

  #endScreen h2.lose-title {
    color: #f55;
    text-shadow: 0 0 40px rgba(255,80,80,0.5);
  }

  #endScreen p { color: #aaa; margin-bottom: 1.5em; }

  #restartBtn {
    font-family: 'Oswald', sans-serif;
    font-size: 1.2rem;
    padding: 0.7em 2.5em;
    background: linear-gradient(180deg, #77dd77, #55bb55);
    color: #1a1a2e;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    font-weight: 700;
    box-shadow: 0 4px 0 #3a8a3a, 0 6px 20px rgba(119,221,119,0.3);
  }

  #restartBtn.lose-btn {
    background: linear-gradient(180deg, #f5a623, #d4891a);
    box-shadow: 0 4px 0 #a06510, 0 6px 20px rgba(245,166,35,0.3);
  }

  @media (max-width: 600px) {
    .ctrl-btn { width: 48px; height: 48px; font-size: 1.2rem; }
    .ctrl-btn.hook-btn { width: 68px; font-size: 0.65rem; }
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<!-- Start Screen -->
<div id="startScreen">
  <h1>Crane Operator</h1>
  <p>Move the crate to the drop zone</p>
  <button id="startBtn">Start Game</button>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-box" id="statusText">Ready</div>
  <div class="hud-box" id="livesText">Lives: 3</div>
  <div class="hud-box" id="scoreText">Crates: 0/3</div>
</div>

<!-- On-screen Controls -->
<div id="controls">
  <div class="ctrl-group">
    <div class="ctrl-row">
      <div style="width:56px"></div>
      <button class="ctrl-btn" data-dir="up">&#9650;</button>
      <div style="width:56px"></div>
    </div>
    <div class="ctrl-row">
      <button class="ctrl-btn" data-dir="left">&#9664;</button>
      <button class="ctrl-btn" data-dir="down">&#9660;</button>
      <button class="ctrl-btn" data-dir="right">&#9654;</button>
    </div>
  </div>
  <button class="ctrl-btn hook-btn" id="hookBtn">Hook</button>
</div>

<!-- End Screen -->
<div id="endScreen">
  <h2 id="endTitle">Job Complete!</h2>
  <p id="endMsg">All crates delivered.</p>
  <button id="restartBtn">Play Again</button>
</div>

<script>
// ============ GAME ENGINE ============
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
resize();
window.addEventListener('resize', resize);

const W = () => window.innerWidth;
const H = () => window.innerHeight;

// ============ GAME STATE ============
const WORLD = {
  groundY: 700,
  craneBaseX: 200,
  craneTopY: 50,
  jibLength: 900,
  towerHeight: 650,
};

let gameState = 'start'; // start, zooming, playing, win
let camera = { x: 0, y: 0, zoom: 0.55 };
let targetCamera = { x: 0, y: 0, zoom: 0.55 };

// Trolley position along the jib (horizontal)
let trolley = {
  x: WORLD.craneBaseX + 200,
  ropeLength: 200,
  speed: 0,
  ropeSpeed: 0,
};

const TROLLEY_MIN_X = WORLD.craneBaseX + 30;
const TROLLEY_MAX_X = WORLD.craneBaseX + WORLD.jibLength - 30;
const ROPE_MIN = 60;
const ROPE_MAX = 680;

// Hook with physics
let hook = {
  x: 0,
  y: 0,
  vx: 0,
  vy: 0,
  angle: 0,       // swing angle
  angleVel: 0,    // swing angular velocity
};

// Cargo
let crates = [];
let obstacles = [];
let dropZone = { x: 900, y: WORLD.groundY - 25, width: 120, height: 50 };
let hookedCrate = null;
let score = 0;
let totalCrates = 3;
let lives = 3;
let hitCooldown = 0; // prevent multiple life losses from single collision
let droppedCrates = []; // crates falling with gravity after release

// Input
let inputState = { left: false, right: false, up: false, down: false };

// Wire segments for visual flex
let wireSegments = [];
const WIRE_SEG_COUNT = 20;

function initWireSegments() {
  wireSegments = [];
  for (let i = 0; i <= WIRE_SEG_COUNT; i++) {
    wireSegments.push({ x: trolley.x, y: WORLD.craneTopY + (trolley.ropeLength * i / WIRE_SEG_COUNT) });
  }
}

function initGame() {
  trolley.x = WORLD.craneBaseX + 150;
  trolley.ropeLength = 200;
  trolley.speed = 0;
  trolley.ropeSpeed = 0;

  hook.x = trolley.x;
  hook.y = WORLD.craneTopY + trolley.ropeLength;
  hook.vx = 0;
  hook.vy = 0;
  hook.angle = 0;
  hook.angleVel = 0;

  crates = [
    { x: WORLD.craneBaseX + 100, y: WORLD.groundY - 50, w: 60, h: 40, color: '#e07030', delivered: false },
    { x: WORLD.craneBaseX + 250, y: WORLD.groundY - 60, w: 50, h: 50, color: '#3090e0', delivered: false },
    { x: WORLD.craneBaseX + 400, y: WORLD.groundY - 45, w: 70, h: 35, color: '#e0d030', delivered: false },
  ];

  // Red obstacles between pickup area and drop zone
  obstacles = [
    { x: WORLD.craneBaseX + 580, y: WORLD.groundY - 180, w: 50, h: 180, color: '#cc2222' },
    { x: WORLD.craneBaseX + 580, y: WORLD.groundY - 250, w: 80, h: 20, color: '#aa1818' },
  ];

  dropZone.x = WORLD.craneBaseX + WORLD.jibLength - 200;
  hookedCrate = null;
  score = 0;
  totalCrates = crates.length;
  lives = 3;
  hitCooldown = 0;
  droppedCrates = [];

  initWireSegments();
  updateHUD();
}

// ============ PHYSICS ============
const TROLLEY_ACCEL = 320;
const TROLLEY_FRICTION = 0.93;
const ROPE_ACCEL = 220;
const ROPE_FRICTION = 0.92;
const GRAVITY = 9.81;
const SWING_DAMPING = 0.988;
const HOOK_MASS_FACTOR = 0.6;

function updatePhysics(dt) {
  // Trolley horizontal movement
  if (inputState.left) trolley.speed -= TROLLEY_ACCEL * dt;
  if (inputState.right) trolley.speed += TROLLEY_ACCEL * dt;
  trolley.speed *= TROLLEY_FRICTION;
  trolley.x += trolley.speed * dt;
  trolley.x = Math.max(TROLLEY_MIN_X, Math.min(TROLLEY_MAX_X, trolley.x));

  // Rope length
  if (inputState.down) trolley.ropeSpeed += ROPE_ACCEL * dt;
  if (inputState.up) trolley.ropeSpeed -= ROPE_ACCEL * dt;
  trolley.ropeSpeed *= ROPE_FRICTION;
  trolley.ropeLength += trolley.ropeSpeed * dt;
  trolley.ropeLength = Math.max(ROPE_MIN, Math.min(ROPE_MAX, trolley.ropeLength));

  // Pendulum physics for hook swing
  // When trolley moves right, hook should lag left (negative angle = left of anchor)
  // Real physics: in the trolley's reference frame, acceleration right creates pseudo-force left on hook
  const trolleyAccel = (inputState.left ? -TROLLEY_ACCEL : 0) + (inputState.right ? TROLLEY_ACCEL : 0);
  const speedFactor = 1 + Math.abs(trolley.speed) * 0.003;
  const gravityRestore = -GRAVITY * Math.sin(hook.angle) * 1.3;
  const trolleyForce = -trolleyAccel * Math.cos(hook.angle) * 0.008 * speedFactor;
  const pendulumAccel = (gravityRestore + trolleyForce) / (trolley.ropeLength * 0.009);
  hook.angleVel += pendulumAccel * dt;
  hook.angleVel *= SWING_DAMPING;
  // Direct velocity-based drag - hook lags behind trolley velocity
  hook.angleVel -= trolley.speed * 0.00001;
  hook.angle += hook.angleVel * dt;

  // Wider clamp to allow bigger swings
  hook.angle = Math.max(-0.75, Math.min(0.75, hook.angle));

  // Compute pendulum target (where the hook WANTS to be)
  const anchorX = trolley.x;
  const anchorY = WORLD.craneTopY;
  const targetHookX = anchorX + Math.sin(hook.angle) * trolley.ropeLength;
  const targetHookY = anchorY + Math.cos(hook.angle) * trolley.ropeLength;

  // Update wire segments with verlet-like flex
  wireSegments[0].x = anchorX;
  wireSegments[0].y = anchorY;

  for (let i = 1; i <= WIRE_SEG_COUNT; i++) {
    const t = i / WIRE_SEG_COUNT;
    const targetX = anchorX + (targetHookX - anchorX) * t;
    const targetY = anchorY + (targetHookY - anchorY) * t;
    // Vertical sag
    const speedSag = Math.abs(trolley.speed) * 0.015;
    const sag = Math.sin(t * Math.PI) * (trolley.ropeLength * 0.018 + Math.abs(hook.angleVel) * 4 + speedSag);
    // Horizontal drag - middle segments lag more, creating a curve
    const lateralDrag = -trolley.speed * 0.12 * Math.sin(t * Math.PI);
    const lerpSpeed = 0.08 + (1 - Math.sin(t * Math.PI)) * 0.06; // ends catch up faster
    wireSegments[i].x += (targetX + lateralDrag - wireSegments[i].x) * lerpSpeed;
    wireSegments[i].y += (targetY + sag - wireSegments[i].y) * lerpSpeed;
  }

  // Hook follows the last wire segment (not the pendulum target directly)
  hook.x = wireSegments[WIRE_SEG_COUNT].x;
  hook.y = wireSegments[WIRE_SEG_COUNT].y;

  // Compute wire angle for crate rotation
  const prevSeg = wireSegments[WIRE_SEG_COUNT - 1];
  const lastSeg = wireSegments[WIRE_SEG_COUNT];
  const currentWireAngle = -Math.atan2(lastSeg.x - prevSeg.x, lastSeg.y - prevSeg.y);

  // Move hooked crate
  if (hookedCrate) {
    hookedCrate.x = hook.x - hookedCrate.w / 2;
    hookedCrate.y = hook.y + 15;
    hookedCrate.rotation = currentWireAngle;
  }

  // Update dropped crates (gravity + collision)
  for (let i = droppedCrates.length - 1; i >= 0; i--) {
    const dc = droppedCrates[i];
    dc.vy += 800 * dt; // gravity
    dc.x += dc.vx * dt;
    dc.y += dc.vy * dt;
    // Dampen rotation towards 0
    dc.rotation *= 0.96;

    // Ground collision
    if (dc.y + dc.h >= WORLD.groundY) {
      dc.y = WORLD.groundY - dc.h;
      dc.vy = 0;
      dc.vx *= 0.3;
      dc.landed = true;
    }

    // Obstacle collision for falling crates
    for (const obs of obstacles) {
      if (dc.x + dc.w > obs.x && dc.x < obs.x + obs.w &&
          dc.y + dc.h > obs.y && dc.y < obs.y + obs.h) {
        // Push out vertically (landed on top)
        if (dc.y + dc.h - obs.y < obs.y + obs.h - dc.y) {
          dc.y = obs.y - dc.h;
          dc.vy = 0;
          dc.vx *= 0.3;
          dc.landed = true;
        }
      }
    }

    // Check if landed in drop zone
    if (dc.landed && !dc.scored) {
      dc.scored = true;
      const cx = dc.x + dc.w / 2;
      if (cx > dropZone.x && cx < dropZone.x + dropZone.width) {
        dc.delivered = true;
        dc.x = dropZone.x + (dropZone.width - dc.w) / 2;
        dc.y = dropZone.y - dc.h + 25;
        const deliveredCount = crates.filter(c => c.delivered).length;
        dc.y -= (deliveredCount - 1) * 35;
        dc.rotation = 0;
        score++;
        updateHUD();
        document.getElementById('statusText').textContent = '\u2713 Delivered!';
        document.getElementById('statusText').style.color = '#77dd77';

        if (score >= totalCrates) {
          setTimeout(() => {
            gameState = 'win';
            showEndScreen(true);
          }, 800);
        } else {
          setTimeout(() => {
            document.getElementById('statusText').textContent = 'Next crate!';
            document.getElementById('statusText').style.color = '#f5a623';
          }, 1000);
        }
      } else {
        document.getElementById('statusText').textContent = 'Missed! Crate lost';
        document.getElementById('statusText').style.color = '#f55';
        setTimeout(() => {
          if (gameState === 'playing') {
            document.getElementById('statusText').textContent = 'Hook another crate';
            document.getElementById('statusText').style.color = '#f5a623';
          }
        }, 1500);
      }
      // Remove from droppedCrates after settling
      setTimeout(() => {
        const idx = droppedCrates.indexOf(dc);
        if (idx !== -1) droppedCrates.splice(idx, 1);
      }, 500);
    }
  }

  // Decrease hit cooldown
  if (hitCooldown > 0) hitCooldown -= dt;

  // Obstacle collision - check hook and hooked crate against obstacles
  for (const obs of obstacles) {
    let wasHit = false;
    // Check hook collision
    if (hook.x > obs.x && hook.x < obs.x + obs.w &&
        hook.y > obs.y && hook.y < obs.y + obs.h) {
      hook.angleVel *= -0.5;
      if (hook.x < obs.x + obs.w / 2) {
        trolley.speed = Math.min(trolley.speed, -40);
      } else {
        trolley.speed = Math.max(trolley.speed, 40);
      }
      wasHit = true;
    }
    // Check hooked crate collision
    if (hookedCrate) {
      if (hookedCrate.x + hookedCrate.w > obs.x && hookedCrate.x < obs.x + obs.w &&
          hookedCrate.y + hookedCrate.h > obs.y && hookedCrate.y < obs.y + obs.h) {
        hook.angleVel *= -0.5;
        if (hookedCrate.x < obs.x) {
          trolley.speed = Math.min(trolley.speed, -60);
        } else {
          trolley.speed = Math.max(trolley.speed, 60);
        }
        wasHit = true;
      }
    }
    if (wasHit && hitCooldown <= 0) {
      hitCooldown = 1.0; // 1 second cooldown between life losses
      lives--;
      updateHUD();
      document.getElementById('statusText').textContent = '\u26a0 Obstacle hit! Lives: ' + lives;
      document.getElementById('statusText').style.color = '#ff4444';
      if (lives <= 0) {
        setTimeout(() => {
          gameState = 'gameover';
          showEndScreen(false);
        }, 600);
      }
    }
  }
}
function updateCamera(dt) {
  if (gameState === 'zooming') {
    // Zoom in on hook
    targetCamera.zoom = 1.4;
    targetCamera.x = hook.x;
    targetCamera.y = hook.y;
  } else if (gameState === 'playing') {
    targetCamera.zoom = 1.3;
    targetCamera.x = hook.x;
    targetCamera.y = hook.y + 30;
  }

  const lerpSpeed = 2.5 * dt;
  camera.x += (targetCamera.x - camera.x) * lerpSpeed;
  camera.y += (targetCamera.y - camera.y) * lerpSpeed;
  camera.zoom += (targetCamera.zoom - camera.zoom) * lerpSpeed;
}

// ============ RENDERING ============
function drawWorld() {
  const w = W();
  const h = H();

  ctx.save();

  // Apply camera transform
  const cx = w / 2 - camera.x * camera.zoom;
  const cy = h / 2 - camera.y * camera.zoom;
  ctx.translate(cx, cy);
  ctx.scale(camera.zoom, camera.zoom);

  // Sky gradient
  const skyGrad = ctx.createLinearGradient(0, -200, 0, WORLD.groundY);
  skyGrad.addColorStop(0, '#1a1a3e');
  skyGrad.addColorStop(0.5, '#2a2a5e');
  skyGrad.addColorStop(1, '#3a3a6e');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(-2000, -500, 5000, WORLD.groundY + 500);

  // Ground
  const gndGrad = ctx.createLinearGradient(0, WORLD.groundY - 10, 0, WORLD.groundY + 300);
  gndGrad.addColorStop(0, '#5a5040');
  gndGrad.addColorStop(0.05, '#4a4030');
  gndGrad.addColorStop(1, '#2a2520');
  ctx.fillStyle = gndGrad;
  ctx.fillRect(-2000, WORLD.groundY - 10, 5000, 500);

  // Ground texture lines
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  for (let i = -2000; i < 3000; i += 40) {
    ctx.beginPath();
    ctx.moveTo(i, WORLD.groundY);
    ctx.lineTo(i + 20, WORLD.groundY + 200);
    ctx.stroke();
  }

  // Draw crane
  drawCrane();

  // Draw drop zone
  drawDropZone();

  // Draw obstacles
  obstacles.forEach(obs => drawObstacle(obs));

  // Draw crates
  crates.forEach(c => {
    if (!c.delivered || c === hookedCrate) return;
    drawCrate(c);
  });
  crates.forEach(c => {
    if (c.delivered || c === hookedCrate) return;
    drawCrate(c);
  });

  // Draw wire
  drawWire();

  // Draw hook
  drawHook();

  // Draw dropped crates (falling)
  droppedCrates.forEach(dc => drawCrate(dc));

  // Draw hooked crate on top
  if (hookedCrate) drawCrate(hookedCrate);

  // Nearby crate indicator
  if (!hookedCrate && gameState === 'playing') {
    const nearby = findNearestCrate();
    if (nearby) {
      ctx.strokeStyle = 'rgba(245,166,35,0.5)';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.strokeRect(nearby.x - 4, nearby.y - 4, nearby.w + 8, nearby.h + 8);
      ctx.setLineDash([]);
    }
  }

  ctx.restore();
}

function drawCrane() {
  const bx = WORLD.craneBaseX;
  const topY = WORLD.craneTopY;
  const gndY = WORLD.groundY;

  // Base feet
  ctx.fillStyle = '#555';
  ctx.fillRect(bx - 80, gndY - 15, 180, 25);

  // Tower (lattice)
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 3;
  const towerW = 30;

  // Main tower verticals
  ctx.beginPath();
  ctx.moveTo(bx - towerW / 2, gndY - 15);
  ctx.lineTo(bx - towerW / 2, topY);
  ctx.moveTo(bx + towerW / 2, gndY - 15);
  ctx.lineTo(bx + towerW / 2, topY);
  ctx.stroke();

  // Cross braces
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = '#555';
  const segH = 50;
  for (let y = gndY - 15; y > topY; y -= segH) {
    ctx.beginPath();
    ctx.moveTo(bx - towerW / 2, y);
    ctx.lineTo(bx + towerW / 2, y - segH);
    ctx.moveTo(bx + towerW / 2, y);
    ctx.lineTo(bx - towerW / 2, y - segH);
    ctx.stroke();
    // Horizontal
    ctx.beginPath();
    ctx.moveTo(bx - towerW / 2, y - segH);
    ctx.lineTo(bx + towerW / 2, y - segH);
    ctx.stroke();
  }

  // Jib (horizontal boom)
  const jibY = topY;
  const jibEnd = bx + WORLD.jibLength;

  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(bx, jibY);
  ctx.lineTo(jibEnd, jibY);
  ctx.moveTo(bx, jibY + 14);
  ctx.lineTo(jibEnd, jibY + 14);
  ctx.stroke();

  // Jib cross braces
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#555';
  const jibSegW = 40;
  for (let x = bx; x < jibEnd; x += jibSegW) {
    ctx.beginPath();
    ctx.moveTo(x, jibY);
    ctx.lineTo(x + jibSegW, jibY + 14);
    ctx.moveTo(x + jibSegW, jibY);
    ctx.lineTo(x, jibY + 14);
    ctx.stroke();
  }

  // Counter jib (left)
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(bx, jibY);
  ctx.lineTo(bx - 100, jibY);
  ctx.moveTo(bx, jibY + 14);
  ctx.lineTo(bx - 100, jibY + 14);
  ctx.stroke();

  // Counterweight
  ctx.fillStyle = '#444';
  ctx.fillRect(bx - 100, jibY - 5, 40, 40);
  ctx.fillStyle = '#555';
  ctx.fillRect(bx - 95, jibY, 30, 30);

  // Cat head / apex
  ctx.strokeStyle = '#777';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(bx, topY - 40);
  ctx.lineTo(bx - 60, jibY);
  ctx.moveTo(bx, topY - 40);
  ctx.lineTo(bx + 80, jibY);
  ctx.stroke();

  // Pendant lines
  ctx.strokeStyle = 'rgba(200,200,200,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(bx, topY - 40);
  ctx.lineTo(jibEnd - 50, jibY);
  ctx.stroke();

  // Operator cab
  ctx.fillStyle = '#f5a623';
  ctx.fillRect(bx - 5, topY + 14, 35, 30);
  ctx.fillStyle = '#88ccff';
  ctx.globalAlpha = 0.5;
  ctx.fillRect(bx, topY + 16, 26, 14);
  ctx.globalAlpha = 1;

  // Trolley
  ctx.fillStyle = '#888';
  ctx.fillRect(trolley.x - 12, topY + 5, 24, 12);
  ctx.fillStyle = '#666';
  ctx.beginPath();
  ctx.arc(trolley.x - 6, topY + 5, 4, 0, Math.PI * 2);
  ctx.arc(trolley.x + 6, topY + 5, 4, 0, Math.PI * 2);
  ctx.fill();
}

function drawWire() {
  // Smooth curve through all wire segments
  ctx.beginPath();
  ctx.moveTo(wireSegments[0].x, wireSegments[0].y);
  for (let i = 1; i < WIRE_SEG_COUNT; i++) {
    const cpx = (wireSegments[i].x + wireSegments[i - 1].x) / 2;
    const cpy = (wireSegments[i].y + wireSegments[i - 1].y) / 2;
    ctx.quadraticCurveTo(wireSegments[i - 1].x, wireSegments[i - 1].y, cpx, cpy);
  }
  ctx.quadraticCurveTo(
    wireSegments[WIRE_SEG_COUNT - 1].x, wireSegments[WIRE_SEG_COUNT - 1].y,
    wireSegments[WIRE_SEG_COUNT].x, wireSegments[WIRE_SEG_COUNT].y
  );
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Wire highlight
  ctx.beginPath();
  ctx.moveTo(wireSegments[0].x + 1, wireSegments[0].y);
  for (let i = 1; i < WIRE_SEG_COUNT; i++) {
    const cpx = (wireSegments[i].x + wireSegments[i - 1].x) / 2 + 1;
    const cpy = (wireSegments[i].y + wireSegments[i - 1].y) / 2;
    ctx.quadraticCurveTo(wireSegments[i - 1].x + 1, wireSegments[i - 1].y, cpx, cpy);
  }
  ctx.quadraticCurveTo(
    wireSegments[WIRE_SEG_COUNT - 1].x + 1, wireSegments[WIRE_SEG_COUNT - 1].y,
    wireSegments[WIRE_SEG_COUNT].x + 1, wireSegments[WIRE_SEG_COUNT].y
  );
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 0.5;
  ctx.stroke();
}

function drawHook() {
  const hx = hook.x;
  const hy = hook.y;

  // Calculate rotation from the last two wire segments (wire direction at bottom)
  const prevSeg = wireSegments[WIRE_SEG_COUNT - 1];
  const lastSeg = wireSegments[WIRE_SEG_COUNT];
  const wireAngle = -Math.atan2(lastSeg.x - prevSeg.x, lastSeg.y - prevSeg.y);

  // Hook body
  ctx.save();
  ctx.translate(hx, hy);
  ctx.rotate(wireAngle);

  // Pulley block
  ctx.fillStyle = '#999';
  ctx.fillRect(-8, -6, 16, 14);
  ctx.fillStyle = '#777';
  ctx.fillRect(-6, -4, 12, 10);

  // Hook shape
  ctx.strokeStyle = hookedCrate ? '#f55' : '#ddd';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(0, 8);
  ctx.lineTo(0, 18);
  ctx.quadraticCurveTo(10, 22, 10, 16);
  ctx.quadraticCurveTo(10, 8, 0, 10);
  ctx.stroke();

  ctx.restore();

  // Hook glow when near crate
  if (!hookedCrate && gameState === 'playing') {
    const nearby = findNearestCrate();
    if (nearby) {
      ctx.beginPath();
      ctx.arc(hx, hy, 20, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(245,166,35,0.15)';
      ctx.fill();
    }
  }
}

function drawCrate(c) {
  ctx.save();

  const cx = c.x + c.w / 2;
  const cy = c.y + c.h / 2;
  const rot = c.rotation || 0;

  ctx.translate(cx, cy);
  ctx.rotate(rot);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(-c.w / 2 + 3, -c.h / 2 + 3, c.w, c.h);

  // Body
  ctx.fillStyle = c.color;
  ctx.fillRect(-c.w / 2, -c.h / 2, c.w, c.h);

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillRect(-c.w / 2, -c.h / 2, c.w, c.h * 0.3);

  // Border
  ctx.strokeStyle = 'rgba(0,0,0,0.3)';
  ctx.lineWidth = 1.5;
  ctx.strokeRect(-c.w / 2, -c.h / 2, c.w, c.h);

  // Cross marking
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-c.w / 2 + 5, -c.h / 2 + 5);
  ctx.lineTo(c.w / 2 - 5, c.h / 2 - 5);
  ctx.moveTo(c.w / 2 - 5, -c.h / 2 + 5);
  ctx.lineTo(-c.w / 2 + 5, c.h / 2 - 5);
  ctx.stroke();

  ctx.restore();
}

function drawObstacle(obs) {
  ctx.save();

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(obs.x + 4, obs.y + 4, obs.w, obs.h);

  // Body
  ctx.fillStyle = obs.color;
  ctx.fillRect(obs.x, obs.y, obs.w, obs.h);

  // Hazard stripes
  ctx.save();
  ctx.beginPath();
  ctx.rect(obs.x, obs.y, obs.w, obs.h);
  ctx.clip();
  ctx.strokeStyle = 'rgba(255,255,0,0.3)';
  ctx.lineWidth = 4;
  const stripeGap = 16;
  for (let i = -obs.h; i < obs.w + obs.h; i += stripeGap) {
    ctx.beginPath();
    ctx.moveTo(obs.x + i, obs.y);
    ctx.lineTo(obs.x + i - obs.h, obs.y + obs.h);
    ctx.stroke();
  }
  ctx.restore();

  // Border glow
  ctx.strokeStyle = 'rgba(255,60,60,0.6)';
  ctx.lineWidth = 2;
  ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(obs.x, obs.y, obs.w, obs.h * 0.15);

  // DANGER label on the wider piece
  if (obs.w >= 60) {
    ctx.fillStyle = '#ffcc00';
    ctx.font = 'bold 14px "Chakra Petch", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('\u26a0 DANGER', obs.x + obs.w / 2, obs.y + obs.h / 2 + 5);
    ctx.textAlign = 'left';
  }

  ctx.restore();
}

function drawDropZone() {
  const dz = dropZone;

  // Striped area
  ctx.fillStyle = 'rgba(119,221,119,0.1)';
  ctx.fillRect(dz.x, dz.y - 80, dz.width, 130);

  ctx.strokeStyle = '#77dd77';
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 6]);
  ctx.strokeRect(dz.x, dz.y - 80, dz.width, 130);
  ctx.setLineDash([]);

  // Label
  ctx.fillStyle = '#77dd77';
  ctx.font = '12px "Chakra Petch", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('DROP ZONE', dz.x + dz.width / 2, dz.y - 88);
  ctx.textAlign = 'left';

  // Ground marker
  ctx.fillStyle = 'rgba(119,221,119,0.3)';
  ctx.fillRect(dz.x, dz.y - 10, dz.width, 35);
}

// ============ HOOK/UNHOOK ============
function findNearestCrate() {
  let best = null;
  let bestDist = 60; // max hook range
  for (const c of crates) {
    if (c.delivered || droppedCrates.includes(c)) continue;
    const cx = c.x + c.w / 2;
    const cy = c.y + c.h / 2;
    const dist = Math.hypot(hook.x - cx, hook.y - cy);
    if (dist < bestDist) {
      bestDist = dist;
      best = c;
    }
  }
  return best;
}

function toggleHook() {
  if (hookedCrate) {
    // Release crate - it falls with gravity
    hookedCrate.vx = trolley.speed * 0.3;
    hookedCrate.vy = 0;
    hookedCrate.landed = false;
    hookedCrate.scored = false;
    droppedCrates.push(hookedCrate);
    hookedCrate = null;
    document.getElementById('hookBtn').textContent = 'Hook';
    document.getElementById('hookBtn').classList.remove('hooked');
    document.getElementById('statusText').textContent = 'Released!';
    document.getElementById('statusText').style.color = '#f5a623';
  } else {
    const crate = findNearestCrate();
    if (crate) {
      hookedCrate = crate;
      document.getElementById('hookBtn').textContent = 'Release';
      document.getElementById('hookBtn').classList.add('hooked');
      document.getElementById('statusText').textContent = 'Hooked! Move to drop zone \u2192';
      document.getElementById('statusText').style.color = '#88ccff';
    } else {
      document.getElementById('statusText').textContent = 'No crate nearby';
      document.getElementById('statusText').style.color = '#f55';
      setTimeout(() => {
        if (gameState === 'playing') {
          document.getElementById('statusText').textContent = 'Lower hook near a crate';
          document.getElementById('statusText').style.color = '#8888aa';
        }
      }, 1500);
    }
  }
}

function updateHUD() {
  document.getElementById('scoreText').textContent = `Crates: ${score}/${totalCrates}`;
  document.getElementById('livesText').textContent = `Lives: ${lives}`;
}

function showEndScreen(won) {
  const el = document.getElementById('endScreen');
  const title = document.getElementById('endTitle');
  const msg = document.getElementById('endMsg');
  const btn = document.getElementById('restartBtn');
  el.style.display = 'flex';
  if (won) {
    title.textContent = 'Job Complete!';
    title.className = 'win-title';
    msg.textContent = 'All crates delivered.';
    btn.className = '';
    btn.textContent = 'Play Again';
  } else {
    title.textContent = 'Game Over';
    title.className = 'lose-title';
    msg.textContent = `You delivered ${score}/${totalCrates} crates.`;
    btn.className = 'lose-btn';
    btn.textContent = 'Try Again';
  }
}

// ============ INPUT ============
// Keyboard
window.addEventListener('keydown', e => {
  if (gameState !== 'playing') return;
  if (e.key === 'ArrowLeft' || e.key === 'a') inputState.left = true;
  if (e.key === 'ArrowRight' || e.key === 'd') inputState.right = true;
  if (e.key === 'ArrowUp' || e.key === 'w') inputState.up = true;
  if (e.key === 'ArrowDown' || e.key === 's') inputState.down = true;
  if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); toggleHook(); }
});

window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') inputState.left = false;
  if (e.key === 'ArrowRight' || e.key === 'd') inputState.right = false;
  if (e.key === 'ArrowUp' || e.key === 'w') inputState.up = false;
  if (e.key === 'ArrowDown' || e.key === 's') inputState.down = false;
});

// Touch / mouse controls
document.querySelectorAll('.ctrl-btn[data-dir]').forEach(btn => {
  const dir = btn.dataset.dir;
  const start = () => { if (gameState === 'playing') { inputState[dir] = true; btn.classList.add('active'); } };
  const end = () => { inputState[dir] = false; btn.classList.remove('active'); };
  btn.addEventListener('mousedown', start);
  btn.addEventListener('mouseup', end);
  btn.addEventListener('mouseleave', end);
  btn.addEventListener('touchstart', e => { e.preventDefault(); start(); });
  btn.addEventListener('touchend', e => { e.preventDefault(); end(); });
  btn.addEventListener('touchcancel', end);
});

document.getElementById('hookBtn').addEventListener('click', () => { if (gameState === 'playing') toggleHook(); });
document.getElementById('hookBtn').addEventListener('touchstart', e => { e.preventDefault(); if (gameState === 'playing') toggleHook(); });

// ============ GAME FLOW ============
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', () => {
  document.getElementById('endScreen').style.display = 'none';
  startGame();
});

function startGame() {
  initGame();
  gameState = 'zooming';

  // Show full crane first
  camera = { x: WORLD.craneBaseX + WORLD.jibLength / 2, y: WORLD.groundY / 2, zoom: 0.45 };
  targetCamera = { ...camera };

  document.getElementById('startScreen').classList.add('hiding');
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('controls').style.display = 'flex';

  document.getElementById('statusText').textContent = 'Zooming in...';
  document.getElementById('statusText').style.color = '#8888aa';

  setTimeout(() => {
    document.getElementById('startScreen').style.display = 'none';
  }, 900);

  // After showing full view, zoom into hook
  setTimeout(() => {
    gameState = 'playing';
    document.getElementById('statusText').textContent = 'Lower hook to a crate';
    document.getElementById('statusText').style.color = '#f5a623';
  }, 2000);
}

// ============ MAIN LOOP ============
let lastTime = 0;

function gameLoop(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;

  if (gameState === 'playing' || gameState === 'zooming') {
    updatePhysics(dt);
    updateCamera(dt);
  }

  // Clear
  ctx.clearRect(0, 0, W(), H());

  // Dark background
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W(), H());

  if (gameState !== 'start') {
    drawWorld();
  }

  // Vignette overlay
  const vGrad = ctx.createRadialGradient(W() / 2, H() / 2, W() * 0.3, W() / 2, H() / 2, W() * 0.8);
  vGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
  ctx.fillStyle = vGrad;
  ctx.fillRect(0, 0, W(), H());

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
