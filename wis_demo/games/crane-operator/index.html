<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Crane Operator ‚Äî Construction Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Oswald:wght@500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #A69D93;
    overflow: hidden;
    font-family: 'Chakra Petch', monospace;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
  }

  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }

  /* Start Screen */
  #startScreen {
    position: fixed;
    inset: 0;
    background: linear-gradient(135deg, #8C90A1, #A69D93, #BBC0CD);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100;
    transition: opacity 0.8s ease, transform 0.8s ease;
  }

  #startScreen.hiding {
    opacity: 0;
    transform: scale(1.1);
    pointer-events: none;
  }

  #startScreen h1 {
    font-family: 'Oswald', sans-serif;
    font-size: clamp(2rem, 6vw, 4.5rem);
    color: #F5C942;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    text-shadow: 0 0 40px rgba(245,198,66,0.4), 0 4px 0 #F37329;
    margin-bottom: 0.3em;
  }

  #startScreen p {
    color: #193E75;
    font-size: clamp(0.8rem, 2vw, 1.1rem);
    margin-bottom: 2em;
    letter-spacing: 0.05em;
    font-weight: 600;
  }

  #startBtn {
    font-family: 'Oswald', sans-serif;
    font-size: 1.4rem;
    padding: 0.8em 3em;
    background: #F37329;
    color: #193E75;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    font-weight: 700;
    box-shadow: 0 6px 0 #193E75, 0 8px 30px rgba(245,198,66,0.3);
    transition: all 0.15s;
  }

  #startBtn:hover { transform: translateY(-2px); box-shadow: 0 8px 0 #193E75, 0 12px 40px rgba(245,198,66,0.4); }
  #startBtn:active { transform: translateY(4px); box-shadow: 0 2px 0 #193E75; }

  /* HUD */
  #hud {
    position: fixed;
    top: 8px;
    left: 8px;
    display: none;
    z-index: 50;
    flex-direction: column;
    gap: 6px;
    align-items: flex-start;
    max-width: calc(100% - 70px);
  }

  #hudRow1 {
    display: flex;
    gap: 8px;
    justify-content: flex-start;
    align-items: center;
    flex-wrap: wrap;
  }

  .hud-box {
    background: rgba(193,62,75,0.85);
    border: 1px solid rgba(245,198,66,0.3);
    border-radius: 6px;
    padding: 4px 10px;
    color: #F5C942;
    font-size: clamp(0.65rem, 2.2vw, 0.85rem);
    font-weight: 600;
    letter-spacing: 0.03em;
    backdrop-filter: blur(8px);
    white-space: nowrap;
    text-align: center;
  }

  #spotterBox {
    background: rgba(25,62,117,0.9);
    border: 1px solid rgba(136,204,255,0.4);
    border-radius: 6px;
    padding: 5px 12px;
    color: #88ccff;
    font-size: clamp(0.7rem, 2.5vw, 0.9rem);
    font-weight: 700;
    letter-spacing: 0.03em;
    backdrop-filter: blur(8px);
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Damage bar */
  #damageWrap {
    background: rgba(25,62,117,0.85);
    border: 1px solid rgba(245,198,66,0.3);
    border-radius: 6px;
    padding: 3px;
    flex: 1;
    max-width: 160px;
    min-width: 80px;
    display: flex;
    align-items: center;
    gap: 6px;
    backdrop-filter: blur(8px);
  }

  #damageLabel {
    color: #F5C942;
    font-size: clamp(0.55rem, 1.8vw, 0.7rem);
    font-weight: 600;
    padding-left: 4px;
    white-space: nowrap;
  }

  #damageTrack {
    flex: 1;
    height: 10px;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
    overflow: hidden;
  }

  #damageFill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #3CA63C, #F5C942, #f55);
    border-radius: 4px;
    transition: width 0.3s ease;
  }

  /* Controls */
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    z-index: 50;
    gap: 12px;
    align-items: end;
  }

  #mobileNavBar {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    height: 116px;
    display: none;
    z-index: 45;
    pointer-events: none;
    background: rgba(25, 62, 117, 0.9);
    border-top: 1px solid rgba(245,198,66,0.28);
    backdrop-filter: blur(4px);
  }

  .ctrl-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  .ctrl-row {
    display: flex;
    gap: 6px;
  }

  .ctrl-btn {
    width: 56px;
    height: 56px;
    border-radius: 10px;
    border: 2px solid rgba(245,198,66,0.5);
    background: rgba(25,62,117,0.8);
    color: #F5C942;
    font-size: 1.4rem;
    font-family: 'Chakra Petch', monospace;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(8px);
    transition: all 0.1s;
    -webkit-tap-highlight-color: transparent;
  }

  .ctrl-btn:active, .ctrl-btn.active {
    background: rgba(245,198,66,0.3);
    border-color: #F5C942;
    transform: scale(0.93);
  }

  .ctrl-btn.hook-btn {
    width: 80px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    line-height: 1.2;
  }

  .ctrl-btn.hook-btn.hooked {
    background: rgba(245,60,60,0.3);
    border-color: #f55;
    color: #f55;
  }

  /* End Screen (win & game over) */
  #endScreen {
    position: fixed;
    inset: 0;
    background: rgba(25,62,117,0.92);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    z-index: 200;
  }

  #endScreen h2 {
    font-family: 'Oswald', sans-serif;
    font-size: 3rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    margin-bottom: 0.5em;
  }

  #endScreen h2.win-title {
    color: #3CA63C;
    text-shadow: 0 0 40px rgba(60,166,60,0.5);
  }

  #endScreen h2.lose-title {
    color: #f55;
    text-shadow: 0 0 40px rgba(255,80,80,0.5);
  }

  #endScreen p { color: #aaa; margin-bottom: 1.5em; }

  #restartBtn {
    font-family: 'Oswald', sans-serif;
    font-size: 1.2rem;
    padding: 0.7em 2.5em;
    background: linear-gradient(180deg, #3CA63C, #2a8a2a);
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    font-weight: 700;
    box-shadow: 0 4px 0 #1a6a1a, 0 6px 20px rgba(60,166,60,0.3);
  }

  #restartBtn.lose-btn {
    background: linear-gradient(180deg, #F5C942, #F37329);
    box-shadow: 0 4px 0 #F1732A, 0 6px 20px rgba(245,198,66,0.3);
  }

  @media (max-width: 600px) {
    .ctrl-btn { width: 48px; height: 48px; font-size: 1.2rem; }
    .ctrl-btn.hook-btn { width: 68px; font-size: 0.65rem; }
    #mobileNavBar { display: block; height: 140px; }
    #controls { bottom: 24px; }
  }

  /* Mobile: ensure HUD doesn't overlap the hamburger menu */
  @media (max-width: 700px) {
    #hud { max-width: calc(100% - 70px); }
    #spotterBox { text-align: left; }
  }

  /* Landscape: move controls to the left */
  @media (orientation: landscape) and (max-height: 500px) {
    #controls {
      left: 16px;
      bottom: 50%;
      transform: translateY(50%);
      flex-direction: column;
      gap: 8px;
    }
    .ctrl-btn { width: 44px; height: 44px; font-size: 1.1rem; }
    .ctrl-btn.hook-btn { width: 64px; height: 44px; font-size: 0.6rem; }
  }

  @media (orientation: landscape) and (min-height: 501px) {
    #controls {
      left: 16px;
      bottom: 50%;
      transform: translateY(50%);
      flex-direction: column;
      gap: 10px;
    }
  }

  /* Hidden SVG container for loading assets */
  #svg-assets {
    position: absolute;
    width: 0;
    height: 0;
    overflow: hidden;
  }
</style>
<link rel="stylesheet" href="../../nav.css?v=1.0.0">
</head>
<body>
<nav class="nav-drawer" id="navDrawer">
  <button class="nav-close" id="navClose" aria-label="Close menu">&times;</button>
  <a href="../../index.html" class="nav-link">Home</a>
  <a href="../../about.html" class="nav-link">About</a>
  <a href="../../mini-games.html" class="nav-link">Mini Games</a>
  <a href="../../contact.html" class="nav-link">Contact</a>
  <a href="../../credits.html" class="nav-link">Credits</a>
</nav>
<div class="nav-scrim" id="navScrim"></div>

<!-- Hamburger menu -->
<button class="menu-btn" id="menuBtn" aria-label="Open menu" style="position: fixed; top: 32px; right: 32px; z-index: 10;">
  <span></span>
  <span></span>
  <span></span>
</button>

<canvas id="gameCanvas"></canvas>

<!-- SVG Assets Container -->
<div id="svg-assets"></div>

<!-- Start Screen -->
<div id="startScreen">
  <h1>Crane Operator</h1>
  <p>Move the crate to the drop zone</p>
  <button id="startBtn">Start Game</button>
</div>

<!-- HUD -->
<div id="hud">
  <div id="hudRow1">
    <div class="hud-box" id="scoreText">Crates: 0/3</div>
    <div id="damageWrap">
      <span id="damageLabel">DMG</span>
      <div id="damageTrack"><div id="damageFill"></div></div>
    </div>
  </div>
  <div id="spotterBox">Ready</div>
</div>

<div id="mobileNavBar" aria-hidden="true"></div>

<!-- On-screen Controls -->
<div id="controls">
  <div class="ctrl-group">
    <div class="ctrl-row">
      <div style="width:56px"></div>
      <button class="ctrl-btn" data-dir="up">&#9650;</button>
      <div style="width:56px"></div>
    </div>
    <div class="ctrl-row">
      <button class="ctrl-btn" data-dir="left">&#9664;</button>
      <button class="ctrl-btn" data-dir="down">&#9660;</button>
      <button class="ctrl-btn" data-dir="right">&#9654;</button>
    </div>
  </div>
  <button class="ctrl-btn hook-btn" id="hookBtn">Hook</button>
</div>

<!-- End Screen -->
<div id="endScreen">
  <h2 id="endTitle">Job Complete!</h2>
  <p id="endMsg">All crates delivered.</p>
  <button id="restartBtn">Play Again</button>
</div>

<script>
// ============ SVG ASSET LOADING ============
const svgAssets = {};
const svgImages = {}; // Store loaded Image objects for rendering
const assetPaths = {
  crane: 'img/crane.svg',
  crate: 'img/crate.svg',
  drum: 'img/drum.svg',
  block: 'img/block.svg',
  hook: 'img/hook.svg',
  tophook: 'img/tophook.svg',
  precast: 'img/precast.svg',
  brokenprecast: 'img/brokenprecast.svg',
  background: 'img/cityscape.svg',
  hill01: 'img/hill01.svg',
  hill02: 'img/hill02.svg'
};

async function loadSVGAssets() {
  const container = document.getElementById('svg-assets');
  const imagePromises = [];

  for (const [name, path] of Object.entries(assetPaths)) {
    // Non-SVG assets (e.g. PNG background) load directly as images.
    if (/\.(png|jpg|jpeg|webp)$/i.test(path)) {
      const promise = new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          svgImages[name] = img;
          resolve();
        };
        img.onerror = () => {
          console.warn(`Failed to load image for ${name}`);
          resolve();
        };
        img.src = path;
      });
      imagePromises.push(promise);
      continue;
    }

    try {
      const response = await fetch(path);
      const svgText = await response.text();
      const div = document.createElement('div');
      div.innerHTML = svgText;
      const svgEl = div.querySelector('svg');
      if (svgEl) {
        container.appendChild(svgEl);
        svgAssets[name] = svgEl;

        // Create Image object for canvas rendering
        const promise = new Promise((resolve) => {
          const img = new Image();
          const svgBlob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          img.onload = () => {
            svgImages[name] = img;
            resolve();
          };
          img.onerror = () => {
            console.warn(`Failed to load image for ${name}`);
            resolve();
          };
          img.src = url;
        });
        imagePromises.push(promise);
      }
    } catch (e) {
      console.warn(`Failed to load ${name}:`, e);
    }
  }

  await Promise.all(imagePromises);
}

// ============ GAME ENGINE ============
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
resize();
window.addEventListener('resize', resize);

const W = () => window.innerWidth;
const H = () => window.innerHeight;

// ============ GAME STATE ============
const WORLD = {
  groundY: 700,
  craneBaseX: 200,
  craneTopY: 245, // 30% shorter tower (650px -> 455px)
  jibLength: 900,
  towerHeight: 455,
};

let gameState = 'start';
let camera = { x: 0, y: 0, zoom: 0.55 };
let targetCamera = { x: 0, y: 0, zoom: 0.55 };
let introOverviewTimer = null;
let introZoomTimer = null;

let trolley = {
  x: WORLD.craneBaseX + 200,
  ropeLength: 200,
  speed: 0,
  ropeSpeed: 0,
};

const TROLLEY_MIN_X = WORLD.craneBaseX + 30;
const TROLLEY_MAX_X = WORLD.craneBaseX + WORLD.jibLength - 30;
const OBSTACLE_BASE_X = WORLD.craneBaseX + 510;
const ROPE_MIN = 60;
const ROPE_MAX = 680;

let hook = {
  x: 0, y: 0, vx: 0, vy: 0,
  angle: 0, angleVel: 0,
};

let crates = [];
let obstacles = [];
let dropZone = { x: 1100, y: WORLD.groundY - 25, width: 120, height: 50 };
let hookedCrate = null;
let score = 0;
let totalCrates = 3;
let damage = 0;
let hitCooldown = 0;
let droppedCrates = [];
let spotterMsg = '';
let spotterArrow = null;
const DROP_ZONE_TOP_Y = () => dropZone.y - 80;

let inputState = { left: false, right: false, up: false, down: false };

let wireSegments = [];
const WIRE_SEG_COUNT = 20;
const WIRE_ANCHOR_Y_OFFSET = 16; // lowered so wire tops sit behind trolley body

function initWireSegments() {
  wireSegments = [];
  for (let i = 0; i <= WIRE_SEG_COUNT; i++) {
    wireSegments.push({ x: trolley.x, y: WORLD.craneTopY + WIRE_ANCHOR_Y_OFFSET + (trolley.ropeLength * i / WIRE_SEG_COUNT) });
  }
}

function initGame() {
  trolley.x = WORLD.craneBaseX + 150;
  trolley.ropeLength = 200;
  trolley.speed = 0;
  trolley.ropeSpeed = 0;

  hook.x = trolley.x;
  hook.y = WORLD.craneTopY + trolley.ropeLength;
  hook.vx = 0; hook.vy = 0;
  hook.angle = 0; hook.angleVel = 0;

  // Precast concrete elements to transport (276x161 aspect ratio from SVG)
  crates = [
    { x: WORLD.craneBaseX + 100, y: WORLD.groundY - 45, w: 80, h: 47, color: '#C0C9CE', type: 'precast', delivered: false },
    { x: WORLD.craneBaseX + 250, y: WORLD.groundY - 45, w: 80, h: 47, color: '#C0C9CE', type: 'precast', delivered: false },
    { x: WORLD.craneBaseX + 400, y: WORLD.groundY - 45, w: 80, h: 47, color: '#C0C9CE', type: 'precast', delivered: false },
  ];

  // Create drum pyramid obstacle (3 levels high)
  const drumW = 38;
  const drumH = 47; // 95:118 ratio, scaled down by ~20%
  const obstacleBaseX = OBSTACLE_BASE_X;

  obstacles = [];
  // Bottom row: 4 drums
  for (let i = 0; i < 4; i++) {
    obstacles.push({
      x: obstacleBaseX + i * drumW,
      y: WORLD.groundY - drumH,
      w: drumW,
      h: drumH,
      color: '#F9893D',
      type: 'drum'
    });
  }
  // Middle row: 3 drums
  for (let i = 0; i < 3; i++) {
    obstacles.push({
      x: obstacleBaseX + drumW/2 + i * drumW,
      y: WORLD.groundY - drumH * 2,
      w: drumW,
      h: drumH,
      color: '#F9893D',
      type: 'drum'
    });
  }
  // Top row: 2 drums
  for (let i = 0; i < 2; i++) {
    obstacles.push({
      x: obstacleBaseX + drumW + i * drumW,
      y: WORLD.groundY - drumH * 3,
      w: drumW,
      h: drumH,
      color: '#F9893D',
      type: 'drum'
    });
  }

  dropZone.x = WORLD.craneBaseX + WORLD.jibLength - 200;
  hookedCrate = null;
  score = 0;
  totalCrates = crates.length;
  damage = 0;
  hitCooldown = 0;
  droppedCrates = [];
  spotterMsg = '';
  spotterArrow = null;

  resetHookBtn();
  initWireSegments();
  updateHUD();
}

function resetHookBtn() {
  document.getElementById('hookBtn').textContent = 'Hook';
  document.getElementById('hookBtn').classList.remove('hooked');
}

// ============ SPOTTER SYSTEM ============
function updateSpotter() {
  const obstacleX = OBSTACLE_BASE_X;
  const obstacleTopY = WORLD.groundY - 250;

  if (!hookedCrate) {
    const avail = crates.find(c => !c.delivered && !droppedCrates.includes(c));
    if (!avail) {
      if (score >= totalCrates) {
        spotterMsg = '';
        spotterArrow = null;
      } else {
        spotterMsg = 'No crates left!';
        spotterArrow = null;
      }
      return;
    }
    const cx = avail.x + avail.w / 2;
    const cy = avail.y + avail.h / 2;
    const dist = Math.hypot(hook.x - cx, hook.y - cy);

    if (dist < 60) {
      spotterMsg = 'ü™ù PRESS HOOK to attach';
      spotterArrow = { x: cx, y: cy - 50, dir: 'down' };
    } else if (hook.y < cy - 80) {
      spotterMsg = '‚¨áÔ∏è LOWER the hook to the crate';
      spotterArrow = { x: cx, y: cy - 60, dir: 'down' };
    } else {
      const dx = cx - hook.x;
      if (Math.abs(dx) > 40) {
        spotterMsg = (dx > 0 ? '‚û°Ô∏è' : '‚¨ÖÔ∏è') + ' Move hook over the crate';
        spotterArrow = { x: cx, y: cy - 60, dir: dx > 0 ? 'right' : 'left' };
      } else {
        spotterMsg = '‚¨áÔ∏è LOWER the hook';
        spotterArrow = { x: cx, y: cy - 60, dir: 'down' };
      }
    }
    return;
  }

  const crateX = hookedCrate.x + hookedCrate.w / 2;
  const crateY = hookedCrate.y + hookedCrate.h;
  const dzCenterX = dropZone.x + dropZone.width / 2;

  if (crateX > dropZone.x && crateX < dropZone.x + dropZone.width) {
    if (crateY >= DROP_ZONE_TOP_Y()) {
      spotterMsg = 'üëç RELEASE now! In the green zone!';
      spotterArrow = { x: dzCenterX, y: dropZone.y - 40, dir: 'down' };
    } else {
      spotterMsg = '‚¨áÔ∏è Lower into the green zone first!';
      spotterArrow = { x: dzCenterX, y: dropZone.y - 40, dir: 'down' };
    }
    return;
  }

  if (crateX > obstacleX + 80) {
    spotterMsg = '‚û°Ô∏è Almost there! Move to drop zone';
    spotterArrow = { x: dzCenterX, y: dropZone.y - 60, dir: 'right' };
    return;
  }

  if (crateX > obstacleX - 100 && crateX < obstacleX + 130) {
    if (crateY > obstacleTopY - 20) {
      spotterMsg = '‚¨ÜÔ∏è RAISE the load! Clear the obstacle!';
      spotterArrow = { x: obstacleX + 25, y: obstacleTopY - 60, dir: 'up' };
    } else {
      spotterMsg = '‚û°Ô∏è Clear! Move past the obstacle';
      spotterArrow = { x: obstacleX + 130, y: obstacleTopY - 40, dir: 'right' };
    }
    return;
  }

  spotterMsg = '‚û°Ô∏è Move right towards drop zone';
  spotterArrow = { x: obstacleX - 30, y: crateY - 60, dir: 'right' };
}

// ============ PHYSICS ============
const TROLLEY_ACCEL = 400;
const TROLLEY_FRICTION = 0.95;
const ROPE_ACCEL = 220;
const ROPE_FRICTION = 0.92;
const GRAVITY = 9.81;
const SWING_DAMPING = 0.988;

function updatePhysics(dt) {
  if (inputState.left) trolley.speed -= TROLLEY_ACCEL * dt;
  if (inputState.right) trolley.speed += TROLLEY_ACCEL * dt;
  trolley.speed *= TROLLEY_FRICTION;
  trolley.x += trolley.speed * dt;
  trolley.x = Math.max(TROLLEY_MIN_X, Math.min(TROLLEY_MAX_X, trolley.x));

  if (inputState.down) trolley.ropeSpeed += ROPE_ACCEL * dt;
  if (inputState.up) trolley.ropeSpeed -= ROPE_ACCEL * dt;
  trolley.ropeSpeed *= ROPE_FRICTION;
  trolley.ropeLength += trolley.ropeSpeed * dt;
  trolley.ropeLength = Math.max(ROPE_MIN, Math.min(ROPE_MAX, trolley.ropeLength));

  const trolleyAccel = (inputState.left ? -TROLLEY_ACCEL : 0) + (inputState.right ? TROLLEY_ACCEL : 0);
  const speedFactor = 1 + Math.abs(trolley.speed) * 0.003;
  const gravityRestore = -GRAVITY * Math.sin(hook.angle) * 1.3;
  const trolleyForce = -trolleyAccel * Math.cos(hook.angle) * 0.008 * speedFactor;
  const pendulumAccel = (gravityRestore + trolleyForce) / (trolley.ropeLength * 0.009);
  hook.angleVel += pendulumAccel * dt;
  hook.angleVel *= SWING_DAMPING;
  hook.angleVel -= trolley.speed * 0.00001;
  hook.angle += hook.angleVel * dt;
  hook.angle = Math.max(-0.75, Math.min(0.75, hook.angle));

  const anchorX = trolley.x;
  const anchorY = WORLD.craneTopY + WIRE_ANCHOR_Y_OFFSET;
  const targetHookX = anchorX + Math.sin(hook.angle) * trolley.ropeLength;
  const targetHookY = anchorY + Math.cos(hook.angle) * trolley.ropeLength;

  wireSegments[0].x = anchorX;
  wireSegments[0].y = anchorY;

  for (let i = 1; i <= WIRE_SEG_COUNT; i++) {
    const t = i / WIRE_SEG_COUNT;
    const targetX = anchorX + (targetHookX - anchorX) * t;
    const targetY = anchorY + (targetHookY - anchorY) * t;
    const speedSag = Math.abs(trolley.speed) * 0.015;
    const sag = Math.sin(t * Math.PI) * (trolley.ropeLength * 0.018 + Math.abs(hook.angleVel) * 4 + speedSag);
    const lateralDrag = -trolley.speed * 0.12 * Math.sin(t * Math.PI);
    const lerpSpeed = 0.08 + (1 - Math.sin(t * Math.PI)) * 0.06;
    wireSegments[i].x += (targetX + lateralDrag - wireSegments[i].x) * lerpSpeed;
    wireSegments[i].y += (targetY + sag - wireSegments[i].y) * lerpSpeed;
  }

  hook.x = wireSegments[WIRE_SEG_COUNT].x;
  hook.y = wireSegments[WIRE_SEG_COUNT].y;

  // --- Hard block: prevent hook/crate from going under obstacles ---
  const obsLeft = OBSTACLE_BASE_X - 10;
  const obsRight = OBSTACLE_BASE_X + 4 * 38 + 10;
  const obsTop = WORLD.groundY - 3 * 47;
  const margin = 8;

  let blockY = null;
  if (hookedCrate) {
    const cLeft = hook.x - hookedCrate.w / 2;
    const cRight = hook.x + hookedCrate.w / 2;
    const cBottom = hook.y + 15 + hookedCrate.h;
    if (cRight > obsLeft && cLeft < obsRight && cBottom > obsTop - margin) {
      blockY = obsTop - margin - 15 - hookedCrate.h;
    }
  } else {
    if (hook.x > obsLeft && hook.x < obsRight && hook.y > obsTop - margin) {
      blockY = obsTop - margin;
    }
  }
  if (blockY !== null && hook.y > blockY) {
    hook.y = blockY;
    wireSegments[WIRE_SEG_COUNT].y = blockY;
    if (hookedCrate) hookedCrate.broken = true;
    if (trolley.ropeSpeed > 0) trolley.ropeSpeed = 0;
    const anchorYBlock = WORLD.craneTopY + WIRE_ANCHOR_Y_OFFSET;
    const dy = hook.y - anchorYBlock;
    const dx = hook.x - trolley.x;
    const maxLen = Math.sqrt(dx * dx + dy * dy);
    if (trolley.ropeLength > maxLen) trolley.ropeLength = maxLen;
    // Trigger collision damage when being pushed into the obstacle
    if (hitCooldown <= 0) {
      hitCooldown = 1.0;
      addDamage(25);
      setSpotterAlert('‚ö†Ô∏è COLLISION! Avoid the obstacle!');
    }
  }

  const prevSeg = wireSegments[WIRE_SEG_COUNT - 1];
  const lastSeg = wireSegments[WIRE_SEG_COUNT];
  const currentWireAngle = -Math.atan2(lastSeg.x - prevSeg.x, lastSeg.y - prevSeg.y);

  if (hookedCrate) {
    hookedCrate.x = hook.x - hookedCrate.w / 2;
    hookedCrate.y = hook.y + 15;
    hookedCrate.rotation = currentWireAngle;
  }

  for (let i = droppedCrates.length - 1; i >= 0; i--) {
    const dc = droppedCrates[i];
    dc.vy += 800 * dt;
    dc.x += dc.vx * dt;
    dc.y += dc.vy * dt;
    dc.rotation *= 0.96;

    if (dc.y + dc.h >= WORLD.groundY) {
      dc.y = WORLD.groundY - dc.h;
      dc.vy = 0;
      dc.vx *= 0.3;
      dc.landed = true;
    }

    for (const obs of obstacles) {
      if (dc.x + dc.w > obs.x && dc.x < obs.x + obs.w &&
          dc.y + dc.h > obs.y && dc.y < obs.y + obs.h) {
        if (dc.y + dc.h - obs.y < obs.y + obs.h - dc.y) {
          dc.y = obs.y - dc.h;
          dc.vy = 0;
          dc.vx *= 0.3;
          dc.landed = true;
        }
      }
    }

    if (dc.landed && !dc.scored) {
      dc.scored = true;
      const cx = dc.x + dc.w / 2;
      const inZone = cx > dropZone.x && cx < dropZone.x + dropZone.width;

      if (dc.releasedTooHigh) {
        dc.broken = true;
        dc.delivered = false;
        setSpotterAlert('‚ö†Ô∏è DROPPED TOO HIGH! Crate destroyed!');
        addDamage(30);
        setTimeout(() => {
          const idx = droppedCrates.indexOf(dc);
          if (idx !== -1) droppedCrates.splice(idx, 1);
        }, 1200);
      } else if (inZone) {
        dc.delivered = true;
        dc.x = dropZone.x + (dropZone.width - dc.w) / 2;
        dc.y = dropZone.y - dc.h + 25;
        const deliveredCount = crates.filter(c => c.delivered).length;
        dc.y -= (deliveredCount - 1) * 35;
        dc.rotation = 0;
        score++;
        updateHUD();
        setSpotterAlert('‚úÖ Delivered! Good work!');

        if (score >= totalCrates) {
          setTimeout(() => {
            gameState = 'win';
            showEndScreen(true);
          }, 800);
        }
        setTimeout(() => {
          const idx = droppedCrates.indexOf(dc);
          if (idx !== -1) droppedCrates.splice(idx, 1);
        }, 500);
      } else {
        setSpotterAlert('‚ùå Missed the drop zone! Crate lost.');
        setTimeout(() => {
          const idx = droppedCrates.indexOf(dc);
          if (idx !== -1) droppedCrates.splice(idx, 1);
        }, 1500);
      }
    }
  }

  if (!hookedCrate) {
    const btn = document.getElementById('hookBtn');
    if (btn.classList.contains('hooked')) resetHookBtn();
  }

  if (hitCooldown > 0) hitCooldown -= dt;

  for (const obs of obstacles) {
    let wasHit = false;
    if (hook.x > obs.x && hook.x < obs.x + obs.w &&
        hook.y > obs.y && hook.y < obs.y + obs.h) {
      hook.angleVel *= -0.5;
      if (hook.x < obs.x + obs.w / 2) trolley.speed = Math.min(trolley.speed, -40);
      else trolley.speed = Math.max(trolley.speed, 40);
      wasHit = true;
    }
    if (hookedCrate) {
      if (hookedCrate.x + hookedCrate.w > obs.x && hookedCrate.x < obs.x + obs.w &&
          hookedCrate.y + hookedCrate.h > obs.y && hookedCrate.y < obs.y + obs.h) {
        hookedCrate.broken = true;
        hook.angleVel *= -0.5;
        if (hookedCrate.x < obs.x) trolley.speed = Math.min(trolley.speed, -60);
        else trolley.speed = Math.max(trolley.speed, 60);
        wasHit = true;
      }
    }
    if (wasHit && hitCooldown <= 0) {
      hitCooldown = 1.0;
      addDamage(25);
      setSpotterAlert('‚ö†Ô∏è COLLISION! Avoid the obstacle!');
    }
  }

  if (gameState === 'playing' && !spotterAlertTimer) {
    updateSpotter();
    document.getElementById('spotterBox').textContent = spotterMsg;
  }
}

let spotterAlertTimer = null;
function setSpotterAlert(msg) {
  document.getElementById('spotterBox').textContent = msg;
  if (spotterAlertTimer) clearTimeout(spotterAlertTimer);
  spotterAlertTimer = setTimeout(() => { spotterAlertTimer = null; }, 2000);
}

function addDamage(amount) {
  damage = Math.min(100, damage + amount);
  updateHUD();
  if (damage >= 100) {
    setTimeout(() => {
      gameState = 'gameover';
      showEndScreen(false);
    }, 600);
  }
}

function updateCamera(dt) {
  if (gameState === 'overview') {
    targetCamera.zoom = 0.52;
    targetCamera.x = WORLD.craneBaseX + WORLD.jibLength / 2;
    targetCamera.y = WORLD.groundY / 2;
  } else if (gameState === 'zooming') {
    targetCamera.zoom = 1.4;
    targetCamera.x = hook.x;
    targetCamera.y = hook.y;
  } else if (gameState === 'playing') {
    targetCamera.zoom = 1.3;
    targetCamera.x = hook.x;
    targetCamera.y = hook.y + 30;
  }
  const lerpSpeed = 2.5 * dt;
  camera.x += (targetCamera.x - camera.x) * lerpSpeed;
  camera.y += (targetCamera.y - camera.y) * lerpSpeed;
  camera.zoom += (targetCamera.zoom - camera.zoom) * lerpSpeed;
}

// ============ RENDERING ============
function drawWorld() {
  const w = W();
  const h = H();
  ctx.save();
  const applyLayerTransform = (parallaxX = 1, parallaxY = 1) => {
    const cx = w / 2 - camera.x * camera.zoom * parallaxX;
    const cy = h / 2 - camera.y * camera.zoom * parallaxY;
    ctx.translate(cx, cy);
    ctx.scale(camera.zoom, camera.zoom);
  };

  // Draw background image in screen space (no blur/filter effects).
  if (svgImages.background) {
    const imgAspect = (svgImages.background.naturalWidth > 0 && svgImages.background.naturalHeight > 0)
      ? (svgImages.background.naturalWidth / svgImages.background.naturalHeight)
      : (w / h);
    const bgH = h;
    const bgW = bgH * imgAspect;
    const bgX = (w - bgW) / 2;
    const bgY = h - bgH;
    ctx.drawImage(svgImages.background, bgX, bgY, bgW, bgH);
  }

  if (!svgImages.background) {
    ctx.save();
    applyLayerTransform(1);
    // Fallback: Sky - lighter gradient
    const skyGrad = ctx.createLinearGradient(0, -200, 0, WORLD.groundY);
    skyGrad.addColorStop(0, '#D8DBE3');
    skyGrad.addColorStop(0.5, '#BBC0CD');
    skyGrad.addColorStop(1, '#A6ADC1');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(-2000, -500, 5000, WORLD.groundY + 500);
    ctx.restore();
  }

  // Hill layers: world-aligned, with depth parallax (hill02 behind hill01).
  if (svgImages.hill02) {
    ctx.save();
    applyLayerTransform(0.58, 1);
    const hillImg = svgImages.hill02;
    const hillW = 2200;
    const hillCenterX = WORLD.craneBaseX + WORLD.jibLength / 2;
    const hillX = hillCenterX - hillW / 2 - 120;
    const aspect = hillImg.naturalWidth > 0 ? (hillImg.naturalHeight / hillImg.naturalWidth) : 0.35;
    const hillH = hillW * aspect;
    const hillY = WORLD.groundY - hillH + 5;
    ctx.drawImage(hillImg, hillX, hillY, hillW, hillH);
    ctx.restore();
  }

  // Foreground hill layer.
  if (svgImages.hill01) {
    ctx.save();
    applyLayerTransform(0.72, 1);
    const hillImg = svgImages.hill01;
    const hillW = 1800;
    const hillCenterX = WORLD.craneBaseX + WORLD.jibLength / 2;
    const hillX = hillCenterX - hillW / 2;
    const aspect = hillImg.naturalWidth > 0 ? (hillImg.naturalHeight / hillImg.naturalWidth) : 0.35;
    const hillH = hillW * aspect;
    const hillY = WORLD.groundY - hillH + 40;
    ctx.drawImage(hillImg, hillX, hillY, hillW, hillH);
    ctx.restore();
  }

  // Ground - solid color
  ctx.save();
  applyLayerTransform(0.88, 1);
  ctx.fillStyle = '#B17F57';
  ctx.fillRect(-2000, WORLD.groundY - 10, 5000, 500);
  ctx.restore();

  ctx.save();
  applyLayerTransform(1);
  drawCrane();
  drawDropZone();
  obstacles.forEach(obs => drawObstacle(obs));

  if (!hookedCrate && gameState === 'playing') {
    const pickupTarget = getPickupTargetCrate();
    if (pickupTarget) drawPickupMarker(pickupTarget);
  }

  crates.forEach(c => { if (!c.delivered || c === hookedCrate) return; drawCrate(c); });
  crates.forEach(c => { if (c.delivered || c === hookedCrate || droppedCrates.includes(c)) return; drawCrate(c); });

  drawWire();
  drawTrolley();
  drawHook();

  droppedCrates.forEach(dc => drawCrate(dc));
  if (hookedCrate) drawCrate(hookedCrate);

  if (spotterArrow && gameState === 'playing') {
    drawSpotterArrow(spotterArrow);
  }

  ctx.restore();
  ctx.restore();
}

function drawSpotterArrow(arrow) {
  const { x, y, dir } = arrow;
  const t = performance.now() / 1000;
  const bob = Math.sin(t * 4) * 6;
  const s = 14;
  const edgePadPx = 18 + s;

  const toScreenX = (wx) => (wx - camera.x) * camera.zoom + W() / 2;
  const toScreenY = (wy) => (wy - camera.y) * camera.zoom + H() / 2;
  const toWorldX = (sx) => (sx - W() / 2) / camera.zoom + camera.x;
  const toWorldY = (sy) => (sy - H() / 2) / camera.zoom + camera.y;

  let minX = edgePadPx;
  let maxX = W() - edgePadPx;
  let minY = edgePadPx;
  let maxY = H() - edgePadPx;

  const navBar = document.getElementById('mobileNavBar');
  if (navBar) {
    const navStyle = getComputedStyle(navBar);
    if (navStyle.display !== 'none') {
      const navRect = navBar.getBoundingClientRect();
      maxY = Math.min(maxY, navRect.top - edgePadPx);
    }
  }

  const controlsEl = document.getElementById('controls');
  if (controlsEl) {
    const controlsStyle = getComputedStyle(controlsEl);
    if (controlsStyle.display !== 'none') {
      const r = controlsEl.getBoundingClientRect();
      if (r.width > 0 && r.height > 0) {
        // Portrait mobile: keep guidance arrow above the control cluster.
        if (window.matchMedia('(max-width: 700px) and (orientation: portrait)').matches) {
          maxY = Math.min(maxY, r.top - edgePadPx);
        }
        // Landscape mobile: controls sit on the left, so keep arrow out of that strip.
        if (window.matchMedia('(orientation: landscape)').matches && r.left < W() * 0.35) {
          minX = Math.max(minX, r.right + edgePadPx);
        }
      }
    }
  }

  // Extra bottom padding on mobile so the down-arrow doesn't go behind the control panel.
  if (window.matchMedia('(max-width: 700px)').matches) {
    maxY -= 120;
  }

  if (minX > maxX) minX = maxX = W() / 2;
  if (minY > maxY) minY = maxY = H() / 2;

  const screenX = toScreenX(x);
  const screenY = toScreenY(y + bob);
  const clampedX = toWorldX(Math.min(maxX, Math.max(minX, screenX)));
  const clampedY = toWorldY(Math.min(maxY, Math.max(minY, screenY)));

  ctx.save();
  ctx.translate(clampedX, clampedY);
  ctx.fillStyle = '#3CA63C';
  ctx.strokeStyle = '#3CA63C';
  ctx.lineWidth = 2;

  ctx.beginPath();
  if (dir === 'down') {
    ctx.moveTo(0, s);
    ctx.lineTo(-s * 0.7, -s * 0.3);
    ctx.lineTo(s * 0.7, -s * 0.3);
  } else if (dir === 'up') {
    ctx.moveTo(0, -s);
    ctx.lineTo(-s * 0.7, s * 0.3);
    ctx.lineTo(s * 0.7, s * 0.3);
  } else if (dir === 'right') {
    ctx.moveTo(s, 0);
    ctx.lineTo(-s * 0.3, -s * 0.7);
    ctx.lineTo(-s * 0.3, s * 0.7);
  } else if (dir === 'left') {
    ctx.moveTo(-s, 0);
    ctx.lineTo(s * 0.3, -s * 0.7);
    ctx.lineTo(s * 0.3, s * 0.7);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawCraneSVG(svg, x, y, width, height) {
  const img = new Image();
  const svgData = new XMLSerializer().serializeToString(svg);
  const blob = new Blob([svgData], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  img.src = url;
  ctx.drawImage(img, x, y, width, height);
  URL.revokeObjectURL(url);
}

function drawCrane() {
  const bx = WORLD.craneBaseX;
  const topY = WORLD.craneTopY;
  const gndY = WORLD.groundY;
  const drawRoundedRect = (x, y, w, h, r) => {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  };

  // Base - using yellow/orange tones from SVG
  ctx.fillStyle = '#B18058';
  ctx.fillRect(bx - 80, gndY - 15, 180, 25);

  // Tower structure - crane yellow
  ctx.strokeStyle = '#F5C942';
  ctx.lineWidth = 3;
  const towerW = 30;

  ctx.beginPath();
  ctx.moveTo(bx - towerW / 2, gndY - 15);
  ctx.lineTo(bx - towerW / 2, topY);
  ctx.moveTo(bx + towerW / 2, gndY - 15);
  ctx.lineTo(bx + towerW / 2, topY);
  ctx.stroke();

  ctx.lineWidth = 1.5;
  ctx.strokeStyle = '#F37329';
  const segH = 50;
  for (let y = gndY - 15; y > topY; y -= segH) {
    ctx.beginPath();
    ctx.moveTo(bx - towerW / 2, y);
    ctx.lineTo(bx + towerW / 2, y - segH);
    ctx.moveTo(bx + towerW / 2, y);
    ctx.lineTo(bx - towerW / 2, y - segH);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bx - towerW / 2, y - segH);
    ctx.lineTo(bx + towerW / 2, y - segH);
    ctx.stroke();
  }

  // Jib - crane yellow
  const jibY = topY;
  const jibEnd = bx + WORLD.jibLength;

  ctx.strokeStyle = '#F5C942';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(bx, jibY);
  ctx.lineTo(jibEnd, jibY);
  ctx.moveTo(bx, jibY + 14);
  ctx.lineTo(jibEnd, jibY + 14);
  ctx.stroke();

  ctx.lineWidth = 1;
  ctx.strokeStyle = '#F37329';
  const jibSegW = 40;
  for (let x = bx; x < jibEnd; x += jibSegW) {
    ctx.beginPath();
    ctx.moveTo(x, jibY);
    ctx.lineTo(x + jibSegW, jibY + 14);
    ctx.moveTo(x + jibSegW, jibY);
    ctx.lineTo(x, jibY + 14);
    ctx.stroke();
  }

  // Counterweight (outer corners rounded, inner touching corners square)
  const cwX = bx - 96;
  const cwY = jibY - 5;
  const cwOrangeW = 13;
  const cwBlueW = 26;
  const cwH = 42;
  const cwRadius = 8;
  const cwOverlap = 4;

  ctx.fillStyle = '#F37329';
  ctx.beginPath();
  ctx.moveTo(cwX + cwRadius, cwY);
  ctx.lineTo(cwX + cwOrangeW + cwOverlap, cwY);
  ctx.lineTo(cwX + cwOrangeW + cwOverlap, cwY + cwH);
  ctx.lineTo(cwX + cwRadius, cwY + cwH);
  ctx.quadraticCurveTo(cwX, cwY + cwH, cwX, cwY + cwH - cwRadius);
  ctx.lineTo(cwX, cwY + cwRadius);
  ctx.quadraticCurveTo(cwX, cwY, cwX + cwRadius, cwY);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = '#3268A5';
  const cwBlueX = cwX + cwOrangeW - cwOverlap;
  ctx.beginPath();
  ctx.moveTo(cwBlueX, cwY);
  ctx.lineTo(cwBlueX + cwBlueW - cwRadius, cwY);
  ctx.quadraticCurveTo(cwBlueX + cwBlueW, cwY, cwBlueX + cwBlueW, cwY + cwRadius);
  ctx.lineTo(cwBlueX + cwBlueW, cwY + cwH - cwRadius);
  ctx.quadraticCurveTo(cwBlueX + cwBlueW, cwY + cwH, cwBlueX + cwBlueW - cwRadius, cwY + cwH);
  ctx.lineTo(cwBlueX, cwY + cwH);
  ctx.lineTo(cwBlueX, cwY);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = '#F5C942';
  drawRoundedRect(bx - 116, jibY + 10, 122, 8, 4);
  ctx.fill();

  // Support cables
  ctx.strokeStyle = '#193E75';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(bx, topY - 40);
  ctx.lineTo(bx - 60, jibY);
  ctx.moveTo(bx, topY - 40);
  ctx.lineTo(bx + 80, jibY);
  ctx.stroke();

  ctx.strokeStyle = 'rgba(25,62,117,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(bx, topY - 40);
  ctx.lineTo(jibEnd - 50, jibY);
  ctx.stroke();

  // Cabin (square with chamfered top-right corner and subtle corner radius)
  const cabinW = 48;
  const cabinH = 54;
  const cabinX = bx - cabinW / 2;
  const cabinY = topY - 5;
  const cabinChamfer = 14;
  const cabinRadius = 5;

  ctx.fillStyle = '#F37329';
  ctx.beginPath();
  ctx.moveTo(cabinX + cabinRadius, cabinY);
  ctx.lineTo(cabinX + cabinW - cabinChamfer, cabinY);
  ctx.lineTo(cabinX + cabinW, cabinY + cabinChamfer);
  ctx.lineTo(cabinX + cabinW, cabinY + cabinH - cabinRadius);
  ctx.quadraticCurveTo(
    cabinX + cabinW,
    cabinY + cabinH,
    cabinX + cabinW - cabinRadius,
    cabinY + cabinH
  );
  ctx.lineTo(cabinX + cabinRadius, cabinY + cabinH);
  ctx.quadraticCurveTo(cabinX, cabinY + cabinH, cabinX, cabinY + cabinH - cabinRadius);
  ctx.lineTo(cabinX, cabinY + cabinRadius);
  ctx.quadraticCurveTo(cabinX, cabinY, cabinX + cabinRadius, cabinY);
  ctx.closePath();
  ctx.fill();

  // Cabin window (square with matching top-right chamfer and subtle corner radius)
  const winX = cabinX + 10;
  const winY = cabinY + 11;
  const winW = 24;
  const winH = 27;
  const winChamfer = 8;
  const winRadius = 3;

  ctx.fillStyle = '#3268A5';
  ctx.beginPath();
  ctx.moveTo(winX + winRadius, winY);
  ctx.lineTo(winX + winW - winChamfer, winY);
  ctx.lineTo(winX + winW, winY + winChamfer);
  ctx.lineTo(winX + winW, winY + winH - winRadius);
  ctx.quadraticCurveTo(winX + winW, winY + winH, winX + winW - winRadius, winY + winH);
  ctx.lineTo(winX + winRadius, winY + winH);
  ctx.quadraticCurveTo(winX, winY + winH, winX, winY + winH - winRadius);
  ctx.lineTo(winX, winY + winRadius);
  ctx.quadraticCurveTo(winX, winY, winX + winRadius, winY);
  ctx.closePath();
  ctx.fill();

}

function drawTrolley() {
  const topY = WORLD.craneTopY;
  ctx.fillStyle = '#F4762B';
  const trolleyX = trolley.x - 17;
  const trolleyY = topY + 14;
  const trolleyW = 34;
  const trolleyH = 12;
  const trolleyRadius = 4;

  ctx.beginPath();
  ctx.moveTo(trolleyX, trolleyY);
  ctx.lineTo(trolleyX + trolleyW, trolleyY);
  ctx.lineTo(trolleyX + trolleyW, trolleyY + trolleyH - trolleyRadius);
  ctx.quadraticCurveTo(
    trolleyX + trolleyW,
    trolleyY + trolleyH,
    trolleyX + trolleyW - trolleyRadius,
    trolleyY + trolleyH
  );
  ctx.lineTo(trolleyX + trolleyRadius, trolleyY + trolleyH);
  ctx.quadraticCurveTo(
    trolleyX,
    trolleyY + trolleyH,
    trolleyX,
    trolleyY + trolleyH - trolleyRadius
  );
  ctx.closePath();
  ctx.fill();
}

function drawWire() {
  const TOP_SPREAD = 8;
  const BOTTOM_SPREAD = 3.5; // slightly closer at the hook, but not touching

  for (let side = -1; side <= 1; side += 2) {
    ctx.beginPath();
    for (let i = 0; i <= WIRE_SEG_COUNT; i++) {
      const t = i / WIRE_SEG_COUNT;
      const spread = TOP_SPREAD + (BOTTOM_SPREAD - TOP_SPREAD) * t;
      const sx = wireSegments[i].x + side * spread;
      const sy = wireSegments[i].y;
      if (i === 0) {
        ctx.moveTo(sx, sy);
      } else {
        const prevT = (i - 1) / WIRE_SEG_COUNT;
        const prevSpread = TOP_SPREAD + (BOTTOM_SPREAD - TOP_SPREAD) * prevT;
        const prevSx = wireSegments[i - 1].x + side * prevSpread;
        const prevSy = wireSegments[i - 1].y;
        const cpx = (prevSx + sx) / 2;
        const cpy = (prevSy + sy) / 2;
        ctx.quadraticCurveTo(prevSx, prevSy, cpx, cpy);
      }
    }
    ctx.strokeStyle = '#193E75';
    ctx.lineWidth = 2.6;
    ctx.stroke();

    ctx.beginPath();
    for (let i = 0; i <= WIRE_SEG_COUNT; i++) {
      const t = i / WIRE_SEG_COUNT;
      const spread = TOP_SPREAD + (BOTTOM_SPREAD - TOP_SPREAD) * t;
      const hlOff = side * (spread + 0.9);
      const sx = wireSegments[i].x + hlOff;
      const sy = wireSegments[i].y;
      if (i === 0) {
        ctx.moveTo(sx, sy);
      } else {
        const prevT = (i - 1) / WIRE_SEG_COUNT;
        const prevSpread = TOP_SPREAD + (BOTTOM_SPREAD - TOP_SPREAD) * prevT;
        const prevHlOff = side * (prevSpread + 0.9);
        const prevSx = wireSegments[i - 1].x + prevHlOff;
        const prevSy = wireSegments[i - 1].y;
        const cpx = (prevSx + sx) / 2;
        const cpy = (prevSy + sy) / 2;
        ctx.quadraticCurveTo(prevSx, prevSy, cpx, cpy);
      }
    }
    ctx.strokeStyle = 'rgba(25,62,117,0.12)';
    ctx.lineWidth = 1.1;
    ctx.stroke();
  }
}

function drawHook() {
  const hx = hook.x;
  const hy = hook.y - 18;
  const prevSeg = wireSegments[WIRE_SEG_COUNT - 1];
  const lastSeg = wireSegments[WIRE_SEG_COUNT];
  const wireAngle = -Math.atan2(lastSeg.x - prevSeg.x, lastSeg.y - prevSeg.y);

  // Hook dimensions (20% smaller: 30px -> 24px)
  const hookWidth = 24;
  const hookHeight = (79 / 37) * hookWidth;

  ctx.save();
  ctx.translate(hx, hy);
  ctx.rotate(wireAngle);

  // Draw hook SVG without color overlay
  if (svgImages.hook) {
    ctx.drawImage(svgImages.hook, -hookWidth / 2, 0, hookWidth, hookHeight);
  }

  ctx.restore();

  // Proximity indicator - centered at bottom of hook
  if (!hookedCrate && gameState === 'playing') {
    const nearby = findNearestCrate();
    if (nearby) {
      ctx.beginPath();
      ctx.arc(hx, hy + hookHeight, 20, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(245,198,66,0.15)';
      ctx.fill();
    }
  }
}

function drawCrate(c) {
  ctx.save();
  const cx = c.x + c.w / 2;
  const cy = c.y + c.h / 2;
  const rot = c.rotation || 0;

  ctx.translate(cx, cy);
  ctx.rotate(rot);

  // Draw SVG if available, otherwise fallback to colored rectangle
  if (c.broken && c.type === 'precast' && svgImages.brokenprecast) {
    // Draw broken precast SVG
    ctx.drawImage(svgImages.brokenprecast, -c.w / 2, -c.h / 2, c.w, c.h);
  } else if (c.broken) {
    // Fallback for broken crates without SVG
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = '#555';
    ctx.fillRect(-c.w / 2, -c.h / 2, c.w, c.h);
    ctx.strokeStyle = '#f55';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-c.w / 2 + 5, -c.h / 2 + 5);
    ctx.lineTo(c.w / 2 - 5, c.h / 2 - 5);
    ctx.moveTo(c.w / 2 - 5, -c.h / 2 + 5);
    ctx.lineTo(-c.w / 2 + 5, c.h / 2 - 5);
    ctx.stroke();
    ctx.globalAlpha = 1;
  } else if (c.type === 'precast' && svgImages.precast) {
    ctx.drawImage(svgImages.precast, -c.w / 2, -c.h / 2, c.w, c.h);
  } else if (c.type === 'drum' && svgImages.drum) {
    ctx.drawImage(svgImages.drum, -c.w / 2, -c.h / 2, c.w, c.h);
  } else if (c.type === 'crate' && svgImages.crate) {
    ctx.drawImage(svgImages.crate, -c.w / 2, -c.h / 2, c.w, c.h);
  } else {
    // Fallback: colored rectangle
    ctx.fillStyle = c.color;
    ctx.fillRect(-c.w / 2, -c.h / 2, c.w, c.h);

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(-c.w / 2, -c.h / 2, c.w, c.h * 0.3);

    // Border
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-c.w / 2, -c.h / 2, c.w, c.h);

    // Detail lines
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-c.w / 2 + 5, -c.h / 2 + 5);
    ctx.lineTo(c.w / 2 - 5, c.h / 2 - 5);
    ctx.moveTo(c.w / 2 - 5, -c.h / 2 + 5);
    ctx.lineTo(-c.w / 2 + 5, c.h / 2 - 5);
    ctx.stroke();
  }

  ctx.restore();
}

function drawObstacle(obs) {
  ctx.save();

  // Draw SVG if available (drums), otherwise fallback
  if (obs.type === 'drum' && svgImages.drum) {
    ctx.drawImage(svgImages.drum, obs.x, obs.y, obs.w, obs.h);
  } else if (obs.type === 'block' && svgImages.block) {
    ctx.drawImage(svgImages.block, obs.x, obs.y, obs.w, obs.h);
  } else {
    // Fallback: colored rectangle with stripes
    ctx.fillStyle = obs.color;
    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);

    // Diagonal stripes
    ctx.save();
    ctx.beginPath();
    ctx.rect(obs.x, obs.y, obs.w, obs.h);
    ctx.clip();
    ctx.strokeStyle = 'rgba(255,198,66,0.3)';
    ctx.lineWidth = 4;
    const stripeGap = 16;
    for (let i = -obs.h; i < obs.w + obs.h; i += stripeGap) {
      ctx.beginPath();
      ctx.moveTo(obs.x + i, obs.y);
      ctx.lineTo(obs.x + i - obs.h, obs.y + obs.h);
      ctx.stroke();
    }
    ctx.restore();

    // Border
    ctx.strokeStyle = 'rgba(128,143,150,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(obs.x, obs.y, obs.w, obs.h * 0.15);

    if (obs.w >= 60) {
      ctx.fillStyle = '#F5C942';
      ctx.font = 'bold 14px "Chakra Petch", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u26a0 DANGER', obs.x + obs.w / 2, obs.y + obs.h / 2 + 5);
      ctx.textAlign = 'left';
    }
  }

  ctx.restore();
}

function drawDropZone() {
  const dz = dropZone;

  // Green safe zone
  ctx.fillStyle = 'rgba(60,166,60,0.1)';
  ctx.fillRect(dz.x, dz.y - 80, dz.width, 130);

  ctx.strokeStyle = '#3CA63C';
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 6]);
  ctx.strokeRect(dz.x, dz.y - 80, dz.width, 130);
  ctx.setLineDash([]);

  ctx.fillStyle = '#3CA63C';
  ctx.font = '12px "Chakra Petch", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('DROP ZONE', dz.x + dz.width / 2, dz.y - 88);
  ctx.textAlign = 'left';

  // Landing platform
  ctx.fillStyle = 'rgba(60,166,60,0.3)';
  ctx.fillRect(dz.x, dz.y - 10, dz.width, 35);
}

function drawPickupMarker(c) {
  const t = performance.now() / 1000;
  const pulse = 1 + Math.sin(t * 4) * 0.06;
  const alpha = 0.55 + Math.sin(t * 4) * 0.12;
  const cx = c.x + c.w / 2;
  const cy = c.y + c.h + 6;
  const rx = Math.max(24, c.w * 0.9) * pulse;
  const ry = Math.max(8, c.h * 0.28) * pulse;

  ctx.save();
  ctx.fillStyle = `rgba(245,201,66,${alpha.toFixed(3)})`;
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// ============ HOOK/UNHOOK ============
function getPickupTargetCrate() {
  return crates.find(c => !c.delivered && !droppedCrates.includes(c)) || null;
}

function findNearestCrate() {
  let best = null;
  let bestDist = 60;
  for (const c of crates) {
    if (c.delivered || droppedCrates.includes(c)) continue;
    const cx = c.x + c.w / 2;
    const cy = c.y + c.h / 2;
    const dist = Math.hypot(hook.x - cx, hook.y - cy);
    if (dist < bestDist) { bestDist = dist; best = c; }
  }
  return best;
}

function toggleHook() {
  if (hookedCrate) {
    hookedCrate.vx = trolley.speed * 0.3;
    hookedCrate.vy = 0;
    hookedCrate.landed = false;
    hookedCrate.scored = false;
    hookedCrate.releasedTooHigh = (hookedCrate.y + hookedCrate.h) < DROP_ZONE_TOP_Y();
    droppedCrates.push(hookedCrate);
    hookedCrate = null;
    resetHookBtn();
  } else {
    const crate = findNearestCrate();
    if (crate) {
      hookedCrate = crate;
      if (typeof hookedCrate.broken !== 'boolean') hookedCrate.broken = false;
      document.getElementById('hookBtn').textContent = 'Release';
      document.getElementById('hookBtn').classList.add('hooked');
    }
  }
}

function updateHUD() {
  document.getElementById('scoreText').textContent = `Crates: ${score}/${totalCrates}`;
  const pct = Math.min(100, Math.max(0, damage));
  document.getElementById('damageFill').style.width = pct + '%';
  const lbl = document.getElementById('damageLabel');
  if (pct > 75) lbl.style.color = '#f55';
  else if (pct > 40) lbl.style.color = '#F5C942';
  else lbl.style.color = '#3CA63C';
}

function showEndScreen(won) {
  const el = document.getElementById('endScreen');
  const title = document.getElementById('endTitle');
  const msg = document.getElementById('endMsg');
  const btn = document.getElementById('restartBtn');
  el.style.display = 'flex';
  if (won) {
    title.textContent = 'Job Complete!';
    title.className = 'win-title';
    msg.textContent = `All crates delivered. Damage: ${Math.round(damage)}%`;
    btn.className = '';
    btn.textContent = 'Play Again';
  } else {
    title.textContent = 'Game Over';
    title.className = 'lose-title';
    msg.textContent = `Too much damage! Delivered ${score}/${totalCrates} crates.`;
    btn.className = 'lose-btn';
    btn.textContent = 'Try Again';
  }
}

// ============ INPUT ============
const keyDirMap = {
  ArrowLeft: 'left', a: 'left',
  ArrowRight: 'right', d: 'right',
  ArrowUp: 'up', w: 'up',
  ArrowDown: 'down', s: 'down',
};

function setDirBtnActive(dir, active) {
  const btn = document.querySelector(`.ctrl-btn[data-dir="${dir}"]`);
  if (btn) btn.classList.toggle('active', active);
}

window.addEventListener('keydown', e => {
  if (gameState !== 'playing') return;
  const dir = keyDirMap[e.key];
  if (dir) { inputState[dir] = true; setDirBtnActive(dir, true); }
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    toggleHook();
    const hb = document.getElementById('hookBtn');
    hb.classList.add('active');
    setTimeout(() => hb.classList.remove('active'), 150);
  }
});

window.addEventListener('keyup', e => {
  const dir = keyDirMap[e.key];
  if (dir) { inputState[dir] = false; setDirBtnActive(dir, false); }
});

document.querySelectorAll('.ctrl-btn[data-dir]').forEach(btn => {
  const dir = btn.dataset.dir;
  const start = () => { if (gameState === 'playing') { inputState[dir] = true; btn.classList.add('active'); } };
  const end = () => { inputState[dir] = false; btn.classList.remove('active'); };
  btn.addEventListener('mousedown', start);
  btn.addEventListener('mouseup', end);
  btn.addEventListener('mouseleave', end);
  btn.addEventListener('touchstart', e => { e.preventDefault(); start(); });
  btn.addEventListener('touchend', e => { e.preventDefault(); end(); });
  btn.addEventListener('touchcancel', end);
});

document.getElementById('hookBtn').addEventListener('click', () => { if (gameState === 'playing') toggleHook(); });
document.getElementById('hookBtn').addEventListener('touchstart', e => { e.preventDefault(); if (gameState === 'playing') toggleHook(); });

// ============ GAME FLOW ============
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', () => {
  document.getElementById('endScreen').style.display = 'none';
  startGame();
});

function startGame() {
  if (introOverviewTimer) clearTimeout(introOverviewTimer);
  if (introZoomTimer) clearTimeout(introZoomTimer);

  initGame();
  gameState = 'overview';

  camera = { x: WORLD.craneBaseX + WORLD.jibLength / 2, y: WORLD.groundY / 2, zoom: 0.52 };
  targetCamera = { ...camera };

  document.getElementById('startScreen').classList.add('hiding');
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('controls').style.display = 'flex';

  document.getElementById('spotterBox').textContent = 'Stand by...';

  setTimeout(() => { document.getElementById('startScreen').style.display = 'none'; }, 900);

  introOverviewTimer = setTimeout(() => {
    gameState = 'zooming';
    introZoomTimer = setTimeout(() => {
      gameState = 'playing';
      document.getElementById('spotterBox').textContent = '‚¨áÔ∏è Lower the hook to a crate';
    }, 1000);
  }, 2000);
}

// ============ MAIN LOOP ============
let lastTime = 0;

function gameLoop(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;

  if (gameState === 'playing' || gameState === 'zooming' || gameState === 'overview') {
    updatePhysics(dt);
    updateCamera(dt);
  }

  ctx.clearRect(0, 0, W(), H());
  ctx.fillStyle = '#A69D93';
  ctx.fillRect(0, 0, W(), H());

  if (gameState !== 'start') drawWorld();

  const vGrad = ctx.createRadialGradient(W() / 2, H() / 2, W() * 0.3, W() / 2, H() / 2, W() * 0.8);
  vGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
  ctx.fillStyle = vGrad;
  ctx.fillRect(0, 0, W(), H());

  requestAnimationFrame(gameLoop);
}

// ============ INITIALIZATION ============
loadSVGAssets().then(() => {
  console.log('SVG assets loaded:', Object.keys(svgAssets));
  console.log('SVG images ready:', Object.keys(svgImages));
  if (!svgImages.hook) console.warn('Hook image not loaded!');
  if (!svgImages.tophook) console.warn('Tophook image not loaded!');
  requestAnimationFrame(gameLoop);
});
</script>
<script src="../../nav.js?v=1.0.0"></script>
</body>
</html>
