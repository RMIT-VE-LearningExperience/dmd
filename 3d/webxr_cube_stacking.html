<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Brick Building Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 280px;
            font-size: 14px;
        }
        
        #vrButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }
        
        #vrButton:hover {
            background: #45a049;
        }
        
        #vrButton:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            max-width: 400px;
        }
        
        #resetButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 12px 24px;
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }
        
        #resetScoreButton {
            position: absolute;
            bottom: 70px;
            left: 20px;
            padding: 8px 16px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            z-index: 1000;
        }
        
        .brick-pattern {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            margin: 8px 0;
        }
        
        .brick-cell {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            padding: 4px;
            text-align: center;
            border-radius: 3px;
            font-size: 12px;
        }
        
        @media (max-width: 768px) {
            #info {
                font-size: 12px;
                padding: 10px;
                max-width: 250px;
            }
            
            #vrButton {
                bottom: 10px;
                right: 10px;
                padding: 10px 20px;
                font-size: 14px;
            }
            
            #resetButton {
                bottom: 10px;
                left: 10px;
                padding: 10px 20px;
                font-size: 14px;
            }
            
            #resetScoreButton {
                bottom: 60px;
                left: 10px;
                padding: 6px 12px;
                font-size: 12px;
            }
            
            #status {
                font-size: 16px;
                padding: 15px;
                max-width: 300px;
            }
            
            .brick-cell {
                font-size: 10px;
                padding: 2px;
            }
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸ§± Brick Wall Building Game</h3>
        <div id="targetOrder" style="font-size: 14px; margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
            <strong>Target: 2x3 Brick Wall (Any Order!):</strong>
            <div id="brickDisplay" class="brick-pattern">
                <div class="brick-cell">1ðŸ”´</div>
                <div class="brick-cell">2ðŸŸ¢</div>
                <div class="brick-cell">3ðŸ”µ</div>
                <div class="brick-cell">4ðŸŸ¡</div>
                <div class="brick-cell">5ðŸŸ </div>
                <div class="brick-cell">6ðŸŸ£</div>
            </div>
            <small style="color: #aaa;">â†‘ Example - arrange bricks in any order you like!</small>
        </div>
        <div id="scoreBoard" style="font-size: 14px; margin: 10px 0;">
            <strong>Score:</strong> <span id="currentScore">0</span> | 
            <strong>Games:</strong> <span id="gamesCount">0</span> |
            <strong>Moves:</strong> <span id="movesCount">0</span>
        </div>
        <p><strong>Goal:</strong> Build a 2x3 brick wall using any arrangement you like!</p>
        <p><strong>VR:</strong> Point and squeeze trigger<br>
        <strong>Desktop:</strong> Click and drag<br>
        <strong>Mobile:</strong> Tap and drag</p>
        <p><strong>Physics:</strong> Bricks auto-stack when dragged over each other!</p>
    </div>
    
    <button id="vrButton">Enter VR</button>
    <button id="resetButton">New Game</button>
    <button id="resetScoreButton">Reset Score</button>
    <div id="status"></div>

    <script>
        let scene, camera, renderer, cubes = [], controllers = [];
        let selectedCube = null, selectedController = null;
        let gameWon = false;
        let TARGET_ARRANGEMENT = [
            { number: 1, color: '#ff4757', emoji: 'ðŸ”´' },
            { number: 2, color: '#2ed573', emoji: 'ðŸŸ¢' },
            { number: 3, color: '#3742fa', emoji: 'ðŸ”µ' },
            { number: 4, color: '#ffa502', emoji: 'ðŸŸ¡' },
            { number: 5, color: '#ff6348', emoji: 'ðŸŸ ' },
            { number: 6, color: '#9c88ff', emoji: 'ðŸŸ£' }
        ]; // Always in numerical order 1-6
        let isMobile = false;
        let touchStartPos = null;
        
        // Scoring system
        let score = 0;
        let gamesPlayed = 0;
        let startTime = 0;
        let moves = 0;
        
        // Brick wall positions (2 rows, 3 columns) - adjusted for brick height
        const BRICK_POSITIONS = [
            // Bottom row (adjusted for brick height)
            { x: -1, y: 0.175, z: -1.5, row: 0, col: 0 },
            { x: 0, y: 0.175, z: -1.5, row: 0, col: 1 },
            { x: 1, y: 0.175, z: -1.5, row: 0, col: 2 },
            // Top row (brick height * 1.5 = 0.525)
            { x: -1, y: 0.525, z: -1.5, row: 1, col: 0 },
            { x: 0, y: 0.525, z: -1.5, row: 1, col: 1 },
            { x: 1, y: 0.525, z: -1.5, row: 1, col: 2 }
        ];
        
        // Raycaster for mouse/controller interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Detect mobile devices
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                  ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        
        init();
        animate();
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 2.5); // Moved back for better VR view
            
            // Renderer with XR support
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Floor with better appearance
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d4a4a,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.5;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create grid markers for brick positions
            createGridMarkers();
            
            // Create movement boundary markers for VR
            createMovementBoundaries();
            
            // Create VR instruction panels
            createVRInstructions();
            
            // Create cubes
            createCubes();
            
            // Setup VR controllers
            setupControllers();
            
            // Setup VR button
            setupVRButton();
            
            // Setup controls based on device
            if (isMobile) {
                setupTouchControls();
            } else {
                setupMouseControls();
            }
            
            // Reset button
            setupResetButton();
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Instructions
            showInstructions();
        }
        
        function createVRInstructions() {
            // Instructions will be attached to left controller dynamically
            // This function now just creates the template
        }
        
        function attachInstructionsToController(controller, isLeftHand = true) {
            // Remove any existing instructions on this controller
            const existingInstructions = controller.getObjectByName('controllerInstructions');
            if (existingInstructions) {
                controller.remove(existingInstructions);
            }
            
            // Create floating instruction panel attached to left controller
            const instructionsGroup = new THREE.Group();
            instructionsGroup.name = 'controllerInstructions';
            
            // Background panel (smaller for hand attachment)
            const panelGeometry = new THREE.PlaneGeometry(0.3, 0.2);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.8 
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            
            // Position relative to controller (above and slightly forward)
            instructionsGroup.position.set(0, 0.15, -0.1);
            instructionsGroup.rotation.x = -Math.PI / 6; // Tilt toward user
            instructionsGroup.add(panel);
            
            // Create text texture for instructions
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 160;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, 256, 160);
            
            // Border
            context.strokeStyle = '#00ff88';
            context.lineWidth = 3;
            context.strokeRect(0, 0, 256, 160);
            
            // Text
            context.fillStyle = '#ffffff';
            context.font = '14px Arial';
            context.textAlign = 'center';
            context.fillText('ðŸ§± Brick Building', 128, 20);
            context.font = '11px Arial';
            context.fillText('Build 2x3 brick wall', 128, 40);
            context.fillText('Any order works!', 128, 55);
            context.fillText('Joystick: Move around', 128, 75);
            context.fillText('Trigger: Grab bricks', 128, 90);
            context.fillText('Auto-stack enabled', 128, 105);
            context.font = '9px Arial';
            context.fillText('Score: Speed + Efficiency', 128, 125);
            context.fillText('Move me to see better!', 128, 140);
            
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture });
            const textMesh = new THREE.Mesh(panelGeometry, textMaterial);
            textMesh.position.z = 0.001; // Slightly in front of background
            
            instructionsGroup.add(textMesh);
            controller.add(instructionsGroup);
            
            return instructionsGroup;
        }
        
        function createVRStatusPanel(message, color = '#ffffff', duration = 3000) {
            // Remove existing status panel
            const existingPanel = scene.getObjectByName('vrStatusPanel');
            if (existingPanel) {
                scene.remove(existingPanel);
            }
            
            const statusGroup = new THREE.Group();
            statusGroup.name = 'vrStatusPanel';
            
            // Background panel
            const panelGeometry = new THREE.PlaneGeometry(2.5, 1);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.9 
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            
            // Position status in front of player
            statusGroup.position.set(0, 1.8, -1.2);
            statusGroup.add(panel);
            
            // Create text texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 200;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, 512, 200);
            
            // Border
            context.strokeStyle = color;
            context.lineWidth = 6;
            context.strokeRect(0, 0, 512, 200);
            
            // Text
            context.fillStyle = color;
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Split message into lines
            const lines = message.split('<br>');
            const lineHeight = 40;
            const startY = 100 - (lines.length - 1) * lineHeight / 2;
            
            lines.forEach((line, index) => {
                // Remove HTML tags for canvas rendering
                const cleanLine = line.replace(/<[^>]*>/g, '');
                context.fillText(cleanLine, 256, startY + index * lineHeight);
            });
            
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture });
            const textMesh = new THREE.Mesh(panelGeometry, textMaterial);
            textMesh.position.z = 0.01;
            
            statusGroup.add(textMesh);
            scene.add(statusGroup);
            
            // Auto-remove after duration
            setTimeout(() => {
                const panel = scene.getObjectByName('vrStatusPanel');
                if (panel) {
                    scene.remove(panel);
                }
            }, duration);
        }
        
        function createGridMarkers() {
            // Create subtle grid markers to show where cubes should go
            BRICK_POSITIONS.forEach((pos, index) => {
                const markerGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                const markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.3
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.rotation.x = -Math.PI / 2;
                marker.position.set(pos.x, pos.y - 0.24, pos.z);
                scene.add(marker);
            });
        }
        
        function createMovementBoundaries() {
            // Create subtle boundary markers to show movement area in VR
            const boundaryGeometry = new THREE.RingGeometry(4.5, 5, 16);
            const boundaryMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const boundaryMarker = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            boundaryMarker.rotation.x = -Math.PI / 2;
            boundaryMarker.position.y = -0.48;
            boundaryMarker.name = 'movementBoundary';
            scene.add(boundaryMarker);
        }
        
        function createNumberTexture(number, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = color;
            context.fillRect(0, 0, 128, 128);
            
            // Border
            context.strokeStyle = '#000000';
            context.lineWidth = 4;
            context.strokeRect(0, 0, 128, 128);
            
            // Number
            context.fillStyle = '#000000';
            context.font = 'bold 80px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(number.toString(), 64, 64);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function updateTargetDisplay() {
            // Show that any order works for the brick wall
            const brickDisplay = document.getElementById('brickDisplay');
            brickDisplay.innerHTML = '';
            
            // Show example arrangement (but emphasize any order works)
            TARGET_ARRANGEMENT.forEach((brick, index) => {
                const cell = document.createElement('div');
                cell.className = 'brick-cell';
                cell.textContent = `${index + 1}${brick.emoji}`;
                cell.style.background = brick.color + '30'; // Semi-transparent
                if (index === 0) {
                    cell.title = 'Example: Any order works!';
                }
                brickDisplay.appendChild(cell);
            });
            
            console.log('Brick wall accepts any arrangement - no specific order required!');
        }
        
        function updateScoreDisplay() {
            document.getElementById('currentScore').textContent = score;
            document.getElementById('gamesCount').textContent = gamesPlayed;
            document.getElementById('movesCount').textContent = moves;
        }
        
        function calculateScore(timeBonus, movesPenalty) {
            // Base score: 150 points (more complex game)
            // Time bonus: up to 75 points (faster = more points)
            // Move penalty: -8 points per move over 6
            let gameScore = 150 + timeBonus - movesPenalty;
            return Math.max(gameScore, 15); // Minimum 15 points
        }
        
        function createCubes() {
            // Create brick geometry instead of cubes (typical brick proportions)
            const brickGeometry = new THREE.BoxGeometry(0.8, 0.35, 0.4); // Length x Height x Width
            const cubeColors = [
                { name: 'red', color: 0xff4757, hexColor: '#ff4757' },
                { name: 'green', color: 0x2ed573, hexColor: '#2ed573' },
                { name: 'blue', color: 0x3742fa, hexColor: '#3742fa' },
                { name: 'yellow', color: 0xffa502, hexColor: '#ffa502' },
                { name: 'orange', color: 0xff6348, hexColor: '#ff6348' },
                { name: 'purple', color: 0x9c88ff, hexColor: '#9c88ff' }
            ];
            
            cubes = []; // Clear existing cubes (keeping variable name for consistency)
            
            cubeColors.forEach((colorData, index) => {
                // Create materials for each face with numbers
                const materials = [];
                for (let i = 0; i < 6; i++) {
                    const texture = createNumberTexture(index + 1, colorData.hexColor);
                    materials.push(new THREE.MeshLambertMaterial({ map: texture }));
                }
                
                const brick = new THREE.Mesh(brickGeometry, materials);
                
                // Position bricks around the player in VR-friendly positions
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 20) {
                    // Position bricks in a semicircle around the player (in front and sides)
                    const angle = (index / cubeColors.length) * Math.PI + Math.PI/4; // 45Â° to 135Â° arc
                    const radius = 1.5 + Math.random() * 0.5; // 1.5-2 meters from player
                    
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius - 0.5; // Slightly forward
                    
                    // Check if position is not in brick area
                    const tooClose = BRICK_POSITIONS.some(pos => {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                        return dist < 1.0;
                    });
                    
                    if (!tooClose) {
                        brick.position.set(x, 0.175, z); // Adjust Y for brick height
                        validPosition = true;
                    }
                    attempts++;
                }
                
                // Fallback positioning if no valid position found
                if (!validPosition) {
                    brick.position.set(
                        (index - 2.5) * 0.8, // Spread horizontally
                        0.175, // Brick height / 2
                        1 // In front of player
                    );
                }
                
                brick.castShadow = true;
                brick.receiveShadow = true;
                
                brick.userData = {
                    number: index + 1,
                    colorName: colorData.name,
                    originalPosition: brick.position.clone(),
                    isGrabbed: false
                };
                
                scene.add(brick);
                cubes.push(brick); // Keep using 'cubes' array name for consistency
            });
            
            gameWon = false;
            moves = 0;
            startTime = Date.now();
            
            // Update display to show that any order works
            updateTargetDisplay();
            updateScoreDisplay();
        }
        
        function getStackHeightAtPosition(x, z, excludeCube) {
            let maxHeight = 0.175; // Start with one brick height
            const tolerance = 0.4; // How close bricks need to be to stack
            
            cubes.forEach(cube => {
                if (cube === excludeCube) return;
                
                const distance = Math.sqrt(
                    Math.pow(cube.position.x - x, 2) + 
                    Math.pow(cube.position.z - z, 2)
                );
                
                if (distance < tolerance) {
                    maxHeight = Math.max(maxHeight, cube.position.y + 0.35); // Brick height
                }
            });
            
            return maxHeight;
        }
        
        function updateStackingFeedback(x, z, excludeCube) {
            // Reset all cube materials
            cubes.forEach(cube => {
                if (cube !== excludeCube && !cube.userData.isGrabbed) {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x000000);
                    });
                }
            });
            
            // Highlight cubes that would be stacked on
            const tolerance = 0.4;
            cubes.forEach(cube => {
                if (cube === excludeCube) return;
                
                const distance = Math.sqrt(
                    Math.pow(cube.position.x - x, 2) + 
                    Math.pow(cube.position.z - z, 2)
                );
                
                if (distance < tolerance) {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x111111);
                    });
                }
            });
        }
        
        function snapToBrickPosition(brick) {
            let bestPosition = null;
            let minDistance = Infinity;
            
            // Find the closest brick position
            BRICK_POSITIONS.forEach((pos, index) => {
                const distance = Math.sqrt(
                    (brick.position.x - pos.x) ** 2 + 
                    (brick.position.z - pos.z) ** 2
                );
                
                if (distance < minDistance && distance < 0.8) { // Larger snapping range for bricks
                    minDistance = distance;
                    bestPosition = { ...pos, index };
                }
            });
            
            if (bestPosition) {
                brick.position.x = bestPosition.x;
                brick.position.z = bestPosition.z;
                
                // Use auto-stacking to determine the correct height
                const stackHeight = getStackHeightAtPosition(bestPosition.x, bestPosition.z, brick);
                brick.position.y = Math.max(stackHeight, bestPosition.y);
                
                return true;
            }
            return false;
        }
        
        function setupControllers() {
            // Setup VR controllers with simple visuals and locomotion
            controllers = []; // Clear any existing controllers
            
            for (let i = 0; i < 2; i++) {
                try {
                    const controller = renderer.xr.getController(i);
                    const controllerGrip = renderer.xr.getControllerGrip(i);
                    
                    // Add event listeners
                    controller.addEventListener('selectstart', onSelectStart);
                    controller.addEventListener('selectend', onSelectEnd);
                    controller.addEventListener('connected', (event) => {
                        console.log(`Controller ${i} connected:`, event.data);
                        
                        // Attach instructions to left controller (typically index 0)
                        if (i === 0 || (event.data.handedness && event.data.handedness === 'left')) {
                            setTimeout(() => {
                                attachInstructionsToController(controller, true);
                            }, 500);
                        }
                    });
                    
                    // Add to scene
                    scene.add(controller);
                    scene.add(controllerGrip);
                    
                    // Create simple visual ray
                    const rayGeometry = new THREE.BufferGeometry();
                    const rayPositions = new Float32Array([
                        0, 0, 0,
                        0, 0, -1
                    ]);
                    rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
                    
                    const rayMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                    const rayLine = new THREE.Line(rayGeometry, rayMaterial);
                    rayLine.scale.z = 3;
                    controller.add(rayLine);
                    
                    // Simple controller handle visual
                    const handleGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.15);
                    const handleMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
                    const handleMesh = new THREE.Mesh(handleGeometry, handleMaterial);
                    controller.add(handleMesh);
                    
                    controllers.push({
                        controller: controller,
                        grip: controllerGrip,
                        index: i,
                        gamepad: null,
                        inputSource: null
                    });
                    
                } catch (error) {
                    console.log(`Controller ${i} setup failed:`, error);
                }
            }
            
            // Fallback: attach instructions to first controller after a delay
            setTimeout(() => {
                if (controllers.length > 0) {
                    attachInstructionsToController(controllers[0].controller, true);
                }
            }, 2000);
            
            console.log(`Initialized ${controllers.length} VR controllers with hand-attached instructions`);
        }
        
        function updateVRLocomotion() {
            if (!renderer.xr.getSession()) return;
            
            const session = renderer.xr.getSession();
            const referenceSpace = renderer.xr.getReferenceSpace();
            
            if (session && session.inputSources) {
                session.inputSources.forEach((inputSource, index) => {
                    if (inputSource.gamepad && controllers[index]) {
                        controllers[index].gamepad = inputSource.gamepad;
                        controllers[index].inputSource = inputSource;
                        
                        const gamepad = inputSource.gamepad;
                        
                        // Check for thumbstick input (usually axes 2,3 for right controller, 0,1 for left)
                        if (gamepad.axes.length >= 4) {
                            let moveX = 0;
                            let moveZ = 0;
                            
                            // Use left controller for movement (typically controller index 0)
                            if (index === 0) {
                                moveX = gamepad.axes[2]; // Left thumbstick X
                                moveZ = gamepad.axes[3]; // Left thumbstick Y
                            }
                            // Or right controller as backup
                            else if (index === 1 && Math.abs(gamepad.axes[2]) > 0.1 || Math.abs(gamepad.axes[3]) > 0.1) {
                                moveX = gamepad.axes[2]; // Right thumbstick X  
                                moveZ = gamepad.axes[3]; // Right thumbstick Y
                            }
                            
                            // Apply deadzone
                            const deadzone = 0.15;
                            if (Math.abs(moveX) < deadzone) moveX = 0;
                            if (Math.abs(moveZ) < deadzone) moveZ = 0;
                            
                            // Apply movement if thumbstick is being used
                            if (Math.abs(moveX) > 0 || Math.abs(moveZ) > 0) {
                                const speed = 0.02; // Movement speed
                                
                                // Get camera direction for forward movement
                                const cameraDirection = new THREE.Vector3();
                                camera.getWorldDirection(cameraDirection);
                                
                                // Create right vector
                                const rightVector = new THREE.Vector3();
                                rightVector.crossVectors(cameraDirection, camera.up).normalize();
                                
                                // Create forward vector (without Y component for ground movement)
                                const forwardVector = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
                                
                                // Calculate movement vector
                                const movement = new THREE.Vector3();
                                movement.addScaledVector(rightVector, moveX * speed);
                                movement.addScaledVector(forwardVector, -moveZ * speed); // Negative because forward is usually negative Z
                                
                                // Apply movement to camera/player position
                                const currentPosition = new THREE.Vector3();
                                camera.getWorldPosition(currentPosition);
                                currentPosition.add(movement);
                                
                                // Simple bounds checking (keep player in reasonable area)
                                const prevX = currentPosition.x;
                                const prevZ = currentPosition.z;
                                
                                currentPosition.x = Math.max(-5, Math.min(5, currentPosition.x));
                                currentPosition.z = Math.max(-3, Math.min(4, currentPosition.z));
                                currentPosition.y = Math.max(0.5, currentPosition.y); // Don't go below ground
                                
                                // Provide haptic feedback if hitting boundary
                                if ((prevX !== currentPosition.x || prevZ !== currentPosition.z) && 
                                    inputSource.hapticActuators && inputSource.hapticActuators[0]) {
                                    inputSource.hapticActuators[0].pulse(0.3, 100); // Light pulse at boundary
                                }
                                
                                // Apply the movement by offsetting the reference space
                                if (referenceSpace) {
                                    const offsetPosition = new THREE.Vector3().subVectors(currentPosition, camera.position);
                                    camera.position.copy(currentPosition);
                                }
                            }
                        }
                    }
                });
            }
        }
        
        function setupVRButton() {
            const vrButton = document.getElementById('vrButton');
            
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.addEventListener('click', () => {
                            if (renderer.xr.getSession()) {
                                renderer.xr.getSession().end();
                            } else {
                                navigator.xr.requestSession('immersive-vr', {
                                    requiredFeatures: ['local-floor'],
                                    optionalFeatures: ['hand-tracking', 'bounded-floor']
                                }).then((session) => {
                                    renderer.xr.setSession(session);
                                }).catch((error) => {
                                    console.log('VR session failed:', error);
                                    showStatus('VR session failed to start', 2000);
                                });
                            }
                        });
                    } else {
                        vrButton.textContent = 'VR Not Supported';
                        vrButton.disabled = true;
                    }
                }).catch(() => {
                    vrButton.textContent = 'VR Not Available';
                    vrButton.disabled = true;
                });
            } else {
                vrButton.textContent = 'WebXR Not Available';
                vrButton.disabled = true;
            }
            
            renderer.xr.addEventListener('sessionstart', () => {
                vrButton.textContent = 'Exit VR';
                // Show VR welcome message
                setTimeout(() => {
                    createVRStatusPanel(
                        `Welcome to VR Mode!<br>Instructions attached to left hand<br>Use joystick to move around<br>Point & squeeze to grab bricks<br>Build any arrangement!`, 
                        '#00ff88', 
                        5000
                    );
                }, 1000);
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                vrButton.textContent = 'Enter VR';
                // Clean up controller-attached instructions
                controllers.forEach(controllerObj => {
                    const instructions = controllerObj.controller.getObjectByName('controllerInstructions');
                    if (instructions) {
                        controllerObj.controller.remove(instructions);
                    }
                });
                // Clean up any floating status panels
                const vrStatus = scene.getObjectByName('vrStatusPanel');
                if (vrStatus) {
                    scene.remove(vrStatus);
                }
            });
        }
        
        function setupMouseControls() {
            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
        }
        
        function setupTouchControls() {
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
        }
        
        function setupResetButton() {
            document.getElementById('resetButton').addEventListener('click', resetGame);
            document.getElementById('resetScoreButton').addEventListener('click', resetScore);
        }
        
        function resetScore() {
            if (confirm('Reset your total score and start fresh?')) {
                score = 0;
                gamesPlayed = 0;
                updateScoreDisplay();
                showStatus('Score Reset! ðŸ”„', 1500);
            }
        }
        
        function resetGame() {
            // Remove existing cubes
            cubes.forEach(cube => scene.remove(cube));
            selectedCube = null;
            selectedController = null;
            
            // Recreate cubes (this will show the same fixed numerical order)
            createCubes();
            showStatus('New Brick Wall Challenge! ðŸ§±<br>Build a 2x3 wall with any arrangement!', 3000);
            
            // Show VR-specific reset message if in VR
            if (renderer.xr.getSession()) {
                createVRStatusPanel(
                    `New Challenge Started!<br>Build any 2x3 brick wall<br>Any order works!<br>Let's build!`, 
                    '#ffaa00', 
                    3000
                );
            }
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            if (gameWon || renderer.xr.getSession()) return;
            
            const touch = event.touches[0];
            touchStartPos = { x: touch.clientX, y: touch.clientY };
            
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0) {
                selectedCube = intersects[0].object;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
                
                // Haptic feedback on mobile (if available)
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (gameWon || !selectedCube || renderer.xr.getSession()) return;
            
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            updateCubePosition();
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            onPointerUp();
        }
        
        function onPointerDown(event) {
            if (gameWon || renderer.xr.getSession()) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0) {
                selectedCube = intersects[0].object;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
            }
        }
        
        function onPointerMove(event) {
            if (gameWon || !selectedCube || renderer.xr.getSession()) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            updateCubePosition();
        }
        
        function updateCubePosition() {
            if (!selectedCube) return;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Project mouse position to a plane
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);
            
            if (intersection) {
                selectedCube.position.x = intersection.x;
                selectedCube.position.z = intersection.z;
                
                // Check if dragging over another cube and auto-stack
                const targetHeight = getStackHeightAtPosition(intersection.x, intersection.z, selectedCube);
                selectedCube.position.y = Math.max(targetHeight, intersection.y);
                
                // Add visual feedback when hovering over stackable position
                updateStackingFeedback(intersection.x, intersection.z, selectedCube);
            }
        }
        
        function onPointerUp() {
            if (selectedCube) {
                selectedCube.userData.isGrabbed = false;
                
                // Clear highlighting
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x000000);
                });
                
                // Clear visual feedback from all cubes
                cubes.forEach(cube => {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x000000);
                    });
                });
                
                // Count this as a move
                moves++;
                updateScoreDisplay();
                
                // Try to snap to brick position
                const snapped = snapToBrickPosition(selectedCube);
                if (snapped) {
                    if (navigator.vibrate) {
                        navigator.vibrate(100); // Stronger feedback for successful placement
                    }
                }
                
                selectedCube = null;
                checkWinCondition();
                
                // Haptic feedback on mobile
                if (navigator.vibrate) {
                    navigator.vibrate(30);
                }
            }
        }
        
        function onSelectStart(event) {
            const controller = event.target;
            
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0 && !gameWon) {
                selectedCube = intersects[0].object;
                selectedController = controller;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
            }
        }
        
        function onSelectEnd() {
            if (selectedCube) {
                selectedCube.userData.isGrabbed = false;
                
                // Clear highlighting
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x000000);
                });
                
                // Clear visual feedback from all cubes
                cubes.forEach(cube => {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x000000);
                    });
                });
                
                // Count this as a move
                moves++;
                updateScoreDisplay();
                
                // Try to snap to brick position
                snapToBrickPosition(selectedCube);
                
                selectedCube = null;
                selectedController = null;
                checkWinCondition();
            }
        }
        
        function checkWinCondition() {
            // Check if all 6 brick positions are filled (any order works!)
            let filledPositions = 0;
            
            BRICK_POSITIONS.forEach((pos, index) => {
                // Find any brick at this position
                const brickAtPosition = cubes.find(brick => 
                    Math.abs(brick.position.x - pos.x) < 0.3 &&
                    Math.abs(brick.position.z - pos.z) < 0.3 &&
                    Math.abs(brick.position.y - pos.y) < 0.2
                );
                
                if (brickAtPosition) {
                    filledPositions++;
                }
            });
            
            // Win if all 6 positions are filled
            if (filledPositions === 6) {
                winGame();
            }
        }
        
        function winGame() {
            gameWon = true;
            gamesPlayed++;
            
            // Calculate score
            const timeTaken = (Date.now() - startTime) / 1000; // seconds
            const timeBonus = Math.max(0, Math.floor(75 - timeTaken * 2)); // Up to 75 bonus points for speed
            const movesPenalty = Math.max(0, (moves - 6) * 8); // -8 points per move over 6
            const gameScore = calculateScore(timeBonus, movesPenalty);
            
            score += gameScore;
            updateScoreDisplay();
            
            // Show detailed win message
            const message = `ðŸ§± Perfect Brick Wall! You Won! ðŸ§±<br>
                           <strong>Game Score: ${gameScore} points</strong><br>
                           Time: ${timeTaken.toFixed(1)}s (${timeBonus > 0 ? '+' + timeBonus : '0'} bonus)<br>
                           Moves: ${moves} (${movesPenalty > 0 ? '-' + movesPenalty : '0'} penalty)<br>
                           <strong>Total Score: ${score}</strong>`;
            
            // Show message both in regular UI and VR
            showStatus(message, 5000);
            
            // Show VR-specific success message if in VR
            if (renderer.xr.getSession()) {
                createVRStatusPanel(
                    `ðŸŽ‰ VICTORY! ðŸŽ‰<br>Perfect Brick Wall Built!<br>Score: ${gameScore} points<br>Total: ${score} points`, 
                    '#00ff00', 
                    4000
                );
            }
            
            // Celebration effect - make all cubes glow
            cubes.forEach(cube => {
                cube.material.forEach(mat => {
                    mat.emissive.setHex(0x222222);
                });
            });
            
            // Victory haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100, 50, 200]);
            }
            
            // Auto-restart after a delay
            setTimeout(() => {
                if (gameWon) { // Only restart if user hasn't manually reset
                    resetGame();
                }
            }, 6000);
        }
        
        function showStatus(message, duration = 2000) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = message;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, duration);
        }
        
        function showInstructions() {
            setTimeout(() => {
                const device = isMobile ? 'Tap' : 'Click';
                const regularMessage = `${device} and drag numbered bricks to build your wall!<br>
                           <strong>Goal:</strong> Fill all 6 positions (2 rows x 3 columns)<br>
                           <strong>Freedom:</strong> Use any arrangement you like!<br>
                           Bricks auto-stack when dragged over each other<br>
                           <strong>Faster + Fewer moves = Higher score!</strong>`;
                
                showStatus(regularMessage, 8000);
                
                // Show VR-specific instructions if in VR
                if (renderer.xr.getSession()) {
                    createVRStatusPanel(
                        `Welcome to VR Brick Building!<br>Use joystick to move around<br>Build any 2x3 arrangement<br>Creative freedom is yours!<br>Good luck!`, 
                        '#00aaff', 
                        6000
                    );
                }
            }, 1000);
        }
        
        function animate() {
            renderer.setAnimationLoop(render);
        }
        
        function render() {
            // Update VR locomotion
            updateVRLocomotion();
            
            // Update grabbed cube position for VR controllers
            if (selectedCube && selectedController) {
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(selectedController.matrixWorld);
                
                const forward = new THREE.Vector3(0, 0, -0.8);
                forward.applyMatrix4(tempMatrix);
                
                const targetPos = selectedController.position.clone();
                targetPos.add(forward);
                
                selectedCube.position.x = targetPos.x;
                selectedCube.position.z = targetPos.z;
                
                // Auto-stack in VR too
                const targetHeight = getStackHeightAtPosition(targetPos.x, targetPos.z, selectedCube);
                selectedCube.position.y = Math.max(targetHeight, targetPos.y);
                
                // Visual feedback for VR stacking
                updateStackingFeedback(targetPos.x, targetPos.z, selectedCube);
            }
            
            // Add gentle floating animation to unplaced cubes
            if (!gameWon) {
                const time = Date.now() * 0.001;
                cubes.forEach((cube, index) => {
                    if (!cube.userData.isGrabbed) {
                        // Check if cube is not in a brick position
                        const inBrickPosition = BRICK_POSITIONS.some(pos => 
                            Math.abs(cube.position.x - pos.x) < 0.1 &&
                            Math.abs(cube.position.z - pos.z) < 0.1
                        );
                        
                        if (!inBrickPosition) {
                            cube.rotation.x = Math.sin(time + index) * 0.02;
                            cube.rotation.y = Math.cos(time + index * 0.7) * 0.02;
                        }
                    }
                });
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>