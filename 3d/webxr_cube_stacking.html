<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Brick Wall Building Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 280px;
            font-size: 14px;
        }
        
        #vrButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }
        
        #vrButton:hover {
            background: #45a049;
        }
        
        #vrButton:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            max-width: 400px;
        }
        
        #resetButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 12px 24px;
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }
        
        #resetScoreButton {
            position: absolute;
            bottom: 70px;
            left: 20px;
            padding: 8px 16px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            z-index: 1000;
        }
        
        .brick-pattern {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            margin: 8px 0;
        }
        
        .brick-cell {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            padding: 4px;
            text-align: center;
            border-radius: 3px;
            font-size: 12px;
        }
        
        @media (max-width: 768px) {
            #info {
                font-size: 12px;
                padding: 10px;
                max-width: 250px;
            }
            
            #vrButton {
                bottom: 10px;
                right: 10px;
                padding: 10px 20px;
                font-size: 14px;
            }
            
            #resetButton {
                bottom: 10px;
                left: 10px;
                padding: 10px 20px;
                font-size: 14px;
            }
            
            #resetScoreButton {
                bottom: 60px;
                left: 10px;
                padding: 6px 12px;
                font-size: 12px;
            }
            
            #status {
                font-size: 16px;
                padding: 15px;
                max-width: 300px;
            }
            
            .brick-cell {
                font-size: 10px;
                padding: 2px;
            }
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸ§± Brick Wall Building Game</h3>
        <div id="targetOrder" style="font-size: 14px; margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
            <strong>Target Brick Wall (Always):</strong>
            <div id="brickDisplay" class="brick-pattern">
                <div class="brick-cell">1ðŸ”´</div>
                <div class="brick-cell">2ðŸŸ¢</div>
                <div class="brick-cell">3ðŸ”µ</div>
                <div class="brick-cell">4ðŸŸ¡</div>
                <div class="brick-cell">5ðŸŸ </div>
                <div class="brick-cell">6ðŸŸ£</div>
            </div>
        </div>
        <div id="scoreBoard" style="font-size: 14px; margin: 10px 0;">
            <strong>Score:</strong> <span id="currentScore">0</span> | 
            <strong>Games:</strong> <span id="gamesCount">0</span> |
            <strong>Moves:</strong> <span id="movesCount">0</span>
        </div>
        <p><strong>Goal:</strong> Build the brick wall: 1-2-3 (bottom row), 4-5-6 (top row)</p>
        <p><strong>VR:</strong> Point and squeeze trigger<br>
        <strong>Desktop:</strong> Click and drag<br>
        <strong>Mobile:</strong> Tap and drag</p>
        <p><strong>Physics:</strong> Cubes auto-stack when dragged over each other!</p>
    </div>
    
    <button id="vrButton">Enter VR</button>
    <button id="resetButton">New Game</button>
    <button id="resetScoreButton">Reset Score</button>
    <div id="status"></div>

    <script>
        let scene, camera, renderer, cubes = [], controllers = [];
        let selectedCube = null, selectedController = null;
        let gameWon = false;
        let TARGET_ARRANGEMENT = [
            { number: 1, color: '#ff4757', emoji: 'ðŸ”´' },
            { number: 2, color: '#2ed573', emoji: 'ðŸŸ¢' },
            { number: 3, color: '#3742fa', emoji: 'ðŸ”µ' },
            { number: 4, color: '#ffa502', emoji: 'ðŸŸ¡' },
            { number: 5, color: '#ff6348', emoji: 'ðŸŸ ' },
            { number: 6, color: '#9c88ff', emoji: 'ðŸŸ£' }
        ]; // Always in numerical order 1-6
        let isMobile = false;
        let touchStartPos = null;
        
        // Scoring system
        let score = 0;
        let gamesPlayed = 0;
        let startTime = 0;
        let moves = 0;
        
        // Brick wall positions (2 rows, 3 columns) - moved further forward for VR
        const BRICK_POSITIONS = [
            // Bottom row (moved forward)
            { x: -1, y: 0, z: -1.5, row: 0, col: 0 },
            { x: 0, y: 0, z: -1.5, row: 0, col: 1 },
            { x: 1, y: 0, z: -1.5, row: 0, col: 2 },
            // Top row
            { x: -1, y: 0.5, z: -1.5, row: 1, col: 0 },
            { x: 0, y: 0.5, z: -1.5, row: 1, col: 1 },
            { x: 1, y: 0.5, z: -1.5, row: 1, col: 2 }
        ];
        
        // Raycaster for mouse/controller interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Detect mobile devices
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                  ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        
        init();
        animate();
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 2.5); // Moved back for better VR view
            
            // Renderer with XR support
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Floor with better appearance
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d4a4a,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.5;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create grid markers for brick positions
            createGridMarkers();
            
            // Create VR instruction panels
            createVRInstructions();
            
            // Create cubes
            createCubes();
            
            // Setup VR controllers
            setupControllers();
            
            // Setup VR button
            setupVRButton();
            
            // Setup controls based on device
            if (isMobile) {
                setupTouchControls();
            } else {
                setupMouseControls();
            }
            
            // Reset button
            setupResetButton();
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Instructions
            showInstructions();
        }
        
        function createVRInstructions() {
            // Create floating instruction panel for VR
            const instructionsGroup = new THREE.Group();
            instructionsGroup.name = 'vrInstructions';
            
            // Background panel
            const panelGeometry = new THREE.PlaneGeometry(3, 1.5);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.8 
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            
            // Position instructions to the right side in VR
            instructionsGroup.position.set(2.5, 1.5, -1);
            instructionsGroup.add(panel);
            
            // Create text texture for instructions
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, 512, 256);
            
            // Border
            context.strokeStyle = '#ffffff';
            context.lineWidth = 4;
            context.strokeRect(0, 0, 512, 256);
            
            // Text
            context.fillStyle = '#ffffff';
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillText('ðŸ§± Brick Wall Building', 256, 40);
            context.font = '18px Arial';
            context.fillText('Bottom row: 1-2-3 (left to right)', 256, 80);
            context.fillText('Top row: 4-5-6 (left to right)', 256, 110);
            context.fillText('Point and squeeze trigger to grab', 256, 150);
            context.fillText('Cubes auto-stack when overlapping', 256, 180);
            context.fillText('Score: Faster + Fewer moves!', 256, 220);
            
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture });
            const textMesh = new THREE.Mesh(panelGeometry, textMaterial);
            textMesh.position.z = 0.01; // Slightly in front of background
            
            instructionsGroup.add(textMesh);
            scene.add(instructionsGroup);
        }
        
        function createVRStatusPanel(message, color = '#ffffff', duration = 3000) {
            // Remove existing status panel
            const existingPanel = scene.getObjectByName('vrStatusPanel');
            if (existingPanel) {
                scene.remove(existingPanel);
            }
            
            const statusGroup = new THREE.Group();
            statusGroup.name = 'vrStatusPanel';
            
            // Background panel
            const panelGeometry = new THREE.PlaneGeometry(2.5, 1);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.9 
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            
            // Position status in front of player
            statusGroup.position.set(0, 1.8, -1.2);
            statusGroup.add(panel);
            
            // Create text texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 200;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, 512, 200);
            
            // Border
            context.strokeStyle = color;
            context.lineWidth = 6;
            context.strokeRect(0, 0, 512, 200);
            
            // Text
            context.fillStyle = color;
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Split message into lines
            const lines = message.split('<br>');
            const lineHeight = 40;
            const startY = 100 - (lines.length - 1) * lineHeight / 2;
            
            lines.forEach((line, index) => {
                // Remove HTML tags for canvas rendering
                const cleanLine = line.replace(/<[^>]*>/g, '');
                context.fillText(cleanLine, 256, startY + index * lineHeight);
            });
            
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture });
            const textMesh = new THREE.Mesh(panelGeometry, textMaterial);
            textMesh.position.z = 0.01;
            
            statusGroup.add(textMesh);
            scene.add(statusGroup);
            
            // Auto-remove after duration
            setTimeout(() => {
                const panel = scene.getObjectByName('vrStatusPanel');
                if (panel) {
                    scene.remove(panel);
                }
            }, duration);
        }
        
        function createGridMarkers() {
            // Create subtle grid markers to show where cubes should go
            BRICK_POSITIONS.forEach((pos, index) => {
                const markerGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                const markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.3
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.rotation.x = -Math.PI / 2;
                marker.position.set(pos.x, pos.y - 0.24, pos.z);
                scene.add(marker);
            });
        }
        
        function createNumberTexture(number, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = color;
            context.fillRect(0, 0, 128, 128);
            
            // Border
            context.strokeStyle = '#000000';
            context.lineWidth = 4;
            context.strokeRect(0, 0, 128, 128);
            
            // Number
            context.fillStyle = '#000000';
            context.font = 'bold 80px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(number.toString(), 64, 64);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function updateTargetDisplay() {
            // Always show numerical order 1-6
            const brickDisplay = document.getElementById('brickDisplay');
            brickDisplay.innerHTML = '';
            TARGET_ARRANGEMENT.forEach(cube => {
                const cell = document.createElement('div');
                cell.className = 'brick-cell';
                cell.textContent = `${cube.number}${cube.emoji}`;
                cell.style.background = cube.color + '30'; // Semi-transparent
                brickDisplay.appendChild(cell);
            });
            
            console.log('Target arrangement is always 1-6 in numerical order');
        }
        
        function updateScoreDisplay() {
            document.getElementById('currentScore').textContent = score;
            document.getElementById('gamesCount').textContent = gamesPlayed;
            document.getElementById('movesCount').textContent = moves;
        }
        
        function calculateScore(timeBonus, movesPenalty) {
            // Base score: 150 points (more complex game)
            // Time bonus: up to 75 points (faster = more points)
            // Move penalty: -8 points per move over 6
            let gameScore = 150 + timeBonus - movesPenalty;
            return Math.max(gameScore, 15); // Minimum 15 points
        }
        
        function createCubes() {
            const cubeGeometry = new THREE.BoxGeometry(0.45, 0.45, 0.45);
            const cubeColors = [
                { name: 'red', color: 0xff4757, hexColor: '#ff4757' },
                { name: 'green', color: 0x2ed573, hexColor: '#2ed573' },
                { name: 'blue', color: 0x3742fa, hexColor: '#3742fa' },
                { name: 'yellow', color: 0xffa502, hexColor: '#ffa502' },
                { name: 'orange', color: 0xff6348, hexColor: '#ff6348' },
                { name: 'purple', color: 0x9c88ff, hexColor: '#9c88ff' }
            ];
            
            cubes = []; // Clear existing cubes
            
            cubeColors.forEach((colorData, index) => {
                // Create materials for each face with numbers
                const materials = [];
                for (let i = 0; i < 6; i++) {
                    const texture = createNumberTexture(index + 1, colorData.hexColor);
                    materials.push(new THREE.MeshLambertMaterial({ map: texture }));
                }
                
                const cube = new THREE.Mesh(cubeGeometry, materials);
                
                // Position cubes around the player in VR-friendly positions
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 20) {
                    // Position cubes in a semicircle around the player (in front and sides)
                    const angle = (index / cubeColors.length) * Math.PI + Math.PI/4; // 45Â° to 135Â° arc
                    const radius = 1.5 + Math.random() * 0.5; // 1.5-2 meters from player
                    
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius - 0.5; // Slightly forward
                    
                    // Check if position is not in brick area
                    const tooClose = BRICK_POSITIONS.some(pos => {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                        return dist < 1.0;
                    });
                    
                    if (!tooClose) {
                        cube.position.set(x, 0, z);
                        validPosition = true;
                    }
                    attempts++;
                }
                
                // Fallback positioning if no valid position found
                if (!validPosition) {
                    cube.position.set(
                        (index - 2.5) * 0.8, // Spread horizontally
                        0,
                        1 // In front of player
                    );
                }
                
                cube.castShadow = true;
                cube.receiveShadow = true;
                
                cube.userData = {
                    number: index + 1,
                    colorName: colorData.name,
                    originalPosition: cube.position.clone(),
                    isGrabbed: false,
                    targetIndex: index // Always in numerical order
                };
                
                scene.add(cube);
                cubes.push(cube);
            });
            
            gameWon = false;
            moves = 0;
            startTime = Date.now();
            
            // Update display to show fixed numerical order
            updateTargetDisplay();
            updateScoreDisplay();
        }
        
        function getStackHeightAtPosition(x, z, excludeCube) {
            let maxHeight = 0;
            const tolerance = 0.4; // How close cubes need to be to stack
            
            cubes.forEach(cube => {
                if (cube === excludeCube) return;
                
                const distance = Math.sqrt(
                    Math.pow(cube.position.x - x, 2) + 
                    Math.pow(cube.position.z - z, 2)
                );
                
                if (distance < tolerance) {
                    maxHeight = Math.max(maxHeight, cube.position.y + 0.5);
                }
            });
            
            return maxHeight;
        }
        
        function updateStackingFeedback(x, z, excludeCube) {
            // Reset all cube materials
            cubes.forEach(cube => {
                if (cube !== excludeCube && !cube.userData.isGrabbed) {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x000000);
                    });
                }
            });
            
            // Highlight cubes that would be stacked on
            const tolerance = 0.4;
            cubes.forEach(cube => {
                if (cube === excludeCube) return;
                
                const distance = Math.sqrt(
                    Math.pow(cube.position.x - x, 2) + 
                    Math.pow(cube.position.z - z, 2)
                );
                
                if (distance < tolerance) {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x111111);
                    });
                }
            });
        }
        
        function snapToBrickPosition(cube) {
            let bestPosition = null;
            let minDistance = Infinity;
            
            // Find the closest brick position
            BRICK_POSITIONS.forEach((pos, index) => {
                const distance = Math.sqrt(
                    (cube.position.x - pos.x) ** 2 + 
                    (cube.position.z - pos.z) ** 2
                );
                
                if (distance < minDistance && distance < 0.7) { // Within snapping range
                    minDistance = distance;
                    bestPosition = { ...pos, index };
                }
            });
            
            if (bestPosition) {
                cube.position.x = bestPosition.x;
                cube.position.z = bestPosition.z;
                
                // Use auto-stacking to determine the correct height
                const stackHeight = getStackHeightAtPosition(bestPosition.x, bestPosition.z, cube);
                cube.position.y = Math.max(stackHeight, bestPosition.y);
                
                return true;
            }
            return false;
        }
        
        function setupControllers() {
            // Setup VR controllers with simple visuals
            controllers = []; // Clear any existing controllers
            
            for (let i = 0; i < 2; i++) {
                try {
                    const controller = renderer.xr.getController(i);
                    
                    // Add event listeners
                    controller.addEventListener('selectstart', onSelectStart);
                    controller.addEventListener('selectend', onSelectEnd);
                    
                    // Add to scene
                    scene.add(controller);
                    
                    // Create simple visual ray
                    const rayGeometry = new THREE.BufferGeometry();
                    const rayPositions = new Float32Array([
                        0, 0, 0,
                        0, 0, -1
                    ]);
                    rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
                    
                    const rayMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                    const rayLine = new THREE.Line(rayGeometry, rayMaterial);
                    rayLine.scale.z = 3;
                    controller.add(rayLine);
                    
                    // Simple controller handle visual
                    const handleGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.15);
                    const handleMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
                    const handleMesh = new THREE.Mesh(handleGeometry, handleMaterial);
                    controller.add(handleMesh);
                    
                    controllers.push({
                        controller: controller,
                        index: i
                    });
                    
                } catch (error) {
                    console.log(`Controller ${i} setup failed:`, error);
                }
            }
            
            console.log(`Initialized ${controllers.length} VR controllers`);
        }
        
        function setupVRButton() {
            const vrButton = document.getElementById('vrButton');
            
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.addEventListener('click', () => {
                            if (renderer.xr.getSession()) {
                                renderer.xr.getSession().end();
                            } else {
                                navigator.xr.requestSession('immersive-vr', {
                                    requiredFeatures: ['local-floor']
                                }).then((session) => {
                                    renderer.xr.setSession(session);
                                }).catch((error) => {
                                    console.log('VR session failed:', error);
                                    showStatus('VR session failed to start', 2000);
                                });
                            }
                        });
                    } else {
                        vrButton.textContent = 'VR Not Supported';
                        vrButton.disabled = true;
                    }
                }).catch(() => {
                    vrButton.textContent = 'VR Not Available';
                    vrButton.disabled = true;
                });
            } else {
                vrButton.textContent = 'WebXR Not Available';
                vrButton.disabled = true;
            }
            
            renderer.xr.addEventListener('sessionstart', () => {
                vrButton.textContent = 'Exit VR';
                // Show VR welcome message
                setTimeout(() => {
                    createVRStatusPanel(
                        `Welcome to VR Mode!<br>Instructions are on your right<br>Point & squeeze to grab cubes<br>Have fun building!`, 
                        '#00ff88', 
                        4000
                    );
                }, 1000);
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                vrButton.textContent = 'Enter VR';
                // Clean up VR-specific elements
                const vrInstructions = scene.getObjectByName('vrInstructions');
                if (vrInstructions) {
                    scene.remove(vrInstructions);
                }
                const vrStatus = scene.getObjectByName('vrStatusPanel');
                if (vrStatus) {
                    scene.remove(vrStatus);
                }
                // Re-create instructions for next VR session
                createVRInstructions();
            });
        }
        
        function setupMouseControls() {
            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
        }
        
        function setupTouchControls() {
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
        }
        
        function setupResetButton() {
            document.getElementById('resetButton').addEventListener('click', resetGame);
            document.getElementById('resetScoreButton').addEventListener('click', resetScore);
        }
        
        function resetScore() {
            if (confirm('Reset your total score and start fresh?')) {
                score = 0;
                gamesPlayed = 0;
                updateScoreDisplay();
                showStatus('Score Reset! ðŸ”„', 1500);
            }
        }
        
        function resetGame() {
            // Remove existing cubes
            cubes.forEach(cube => scene.remove(cube));
            selectedCube = null;
            selectedController = null;
            
            // Recreate cubes (this will show the same fixed numerical order)
            createCubes();
            showStatus('New Brick Wall Challenge! ðŸ§±<br>Build the wall: 1-2-3 (bottom), 4-5-6 (top)!', 3000);
            
            // Show VR-specific reset message if in VR
            if (renderer.xr.getSession()) {
                createVRStatusPanel(
                    `New Challenge Started!<br>Build: 1-2-3 bottom row<br>Then: 4-5-6 top row<br>Let's go!`, 
                    '#ffaa00', 
                    3000
                );
            }
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            if (gameWon || renderer.xr.getSession()) return;
            
            const touch = event.touches[0];
            touchStartPos = { x: touch.clientX, y: touch.clientY };
            
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0) {
                selectedCube = intersects[0].object;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
                
                // Haptic feedback on mobile (if available)
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (gameWon || !selectedCube || renderer.xr.getSession()) return;
            
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            updateCubePosition();
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            onPointerUp();
        }
        
        function onPointerDown(event) {
            if (gameWon || renderer.xr.getSession()) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0) {
                selectedCube = intersects[0].object;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
            }
        }
        
        function onPointerMove(event) {
            if (gameWon || !selectedCube || renderer.xr.getSession()) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            updateCubePosition();
        }
        
        function updateCubePosition() {
            if (!selectedCube) return;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Project mouse position to a plane
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);
            
            if (intersection) {
                selectedCube.position.x = intersection.x;
                selectedCube.position.z = intersection.z;
                
                // Check if dragging over another cube and auto-stack
                const targetHeight = getStackHeightAtPosition(intersection.x, intersection.z, selectedCube);
                selectedCube.position.y = Math.max(targetHeight, intersection.y);
                
                // Add visual feedback when hovering over stackable position
                updateStackingFeedback(intersection.x, intersection.z, selectedCube);
            }
        }
        
        function onPointerUp() {
            if (selectedCube) {
                selectedCube.userData.isGrabbed = false;
                
                // Clear highlighting
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x000000);
                });
                
                // Clear visual feedback from all cubes
                cubes.forEach(cube => {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x000000);
                    });
                });
                
                // Count this as a move
                moves++;
                updateScoreDisplay();
                
                // Try to snap to brick position
                const snapped = snapToBrickPosition(selectedCube);
                if (snapped) {
                    if (navigator.vibrate) {
                        navigator.vibrate(100); // Stronger feedback for successful placement
                    }
                }
                
                selectedCube = null;
                checkWinCondition();
                
                // Haptic feedback on mobile
                if (navigator.vibrate) {
                    navigator.vibrate(30);
                }
            }
        }
        
        function onSelectStart(event) {
            const controller = event.target;
            
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0 && !gameWon) {
                selectedCube = intersects[0].object;
                selectedController = controller;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
            }
        }
        
        function onSelectEnd() {
            if (selectedCube) {
                selectedCube.userData.isGrabbed = false;
                
                // Clear highlighting
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x000000);
                });
                
                // Clear visual feedback from all cubes
                cubes.forEach(cube => {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x000000);
                    });
                });
                
                // Count this as a move
                moves++;
                updateScoreDisplay();
                
                // Try to snap to brick position
                snapToBrickPosition(selectedCube);
                
                selectedCube = null;
                selectedController = null;
                checkWinCondition();
            }
        }
        
        function checkWinCondition() {
            // Check if all cubes are in correct brick positions
            let correctPlacements = 0;
            
            BRICK_POSITIONS.forEach((pos, index) => {
                // Find cube at this position
                const cubeAtPosition = cubes.find(cube => 
                    Math.abs(cube.position.x - pos.x) < 0.1 &&
                    Math.abs(cube.position.z - pos.z) < 0.1 &&
                    Math.abs(cube.position.y - pos.y) < 0.1
                );
                
                if (cubeAtPosition) {
                    // Check if it's the correct cube for this position
                    const expectedCube = TARGET_ARRANGEMENT[index];
                    if (cubeAtPosition.userData.number === expectedCube.number) {
                        correctPlacements++;
                    }
                }
            });
            
            if (correctPlacements === 6) {
                winGame();
            }
        }
        
        function winGame() {
            gameWon = true;
            gamesPlayed++;
            
            // Calculate score
            const timeTaken = (Date.now() - startTime) / 1000; // seconds
            const timeBonus = Math.max(0, Math.floor(75 - timeTaken * 2)); // Up to 75 bonus points for speed
            const movesPenalty = Math.max(0, (moves - 6) * 8); // -8 points per move over 6
            const gameScore = calculateScore(timeBonus, movesPenalty);
            
            score += gameScore;
            updateScoreDisplay();
            
            // Show detailed win message
            const message = `ðŸ§± Perfect Brick Wall! You Won! ðŸ§±<br>
                           <strong>Game Score: ${gameScore} points</strong><br>
                           Time: ${timeTaken.toFixed(1)}s (${timeBonus > 0 ? '+' + timeBonus : '0'} bonus)<br>
                           Moves: ${moves} (${movesPenalty > 0 ? '-' + movesPenalty : '0'} penalty)<br>
                           <strong>Total Score: ${score}</strong>`;
            
            // Show message both in regular UI and VR
            showStatus(message, 5000);
            
            // Show VR-specific success message if in VR
            if (renderer.xr.getSession()) {
                createVRStatusPanel(
                    `ðŸŽ‰ VICTORY! ðŸŽ‰<br>Perfect Brick Wall Built!<br>Score: ${gameScore} points<br>Total: ${score} points`, 
                    '#00ff00', 
                    4000
                );
            }
            
            // Celebration effect - make all cubes glow
            cubes.forEach(cube => {
                cube.material.forEach(mat => {
                    mat.emissive.setHex(0x222222);
                });
            });
            
            // Victory haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100, 50, 200]);
            }
            
            // Auto-restart after a delay
            setTimeout(() => {
                if (gameWon) { // Only restart if user hasn't manually reset
                    resetGame();
                }
            }, 6000);
        }
        
        function showStatus(message, duration = 2000) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = message;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, duration);
        }
        
        function showInstructions() {
            setTimeout(() => {
                const device = isMobile ? 'Tap' : 'Click';
                const regularMessage = `${device} and drag numbered cubes to build the brick wall!<br>
                           <strong>Bottom row:</strong> 1-2-3 (left to right)<br>
                           <strong>Top row:</strong> 4-5-6 (left to right)<br>
                           Cubes auto-stack when dragged over each other<br>
                           <strong>Faster + Fewer moves = Higher score!</strong>`;
                
                showStatus(regularMessage, 7000);
                
                // Show VR-specific instructions if in VR
                if (renderer.xr.getSession()) {
                    createVRStatusPanel(
                        `Welcome to VR Brick Building!<br>Point controllers and squeeze to grab<br>Build: 1-2-3 bottom, 4-5-6 top<br>Good luck!`, 
                        '#00aaff', 
                        5000
                    );
                }
            }, 1000);
        }
        
        function animate() {
            renderer.setAnimationLoop(render);
        }
        
        function render() {
            // Update grabbed cube position for VR controllers
            if (selectedCube && selectedController) {
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(selectedController.matrixWorld);
                
                const forward = new THREE.Vector3(0, 0, -0.8);
                forward.applyMatrix4(tempMatrix);
                
                const targetPos = selectedController.position.clone();
                targetPos.add(forward);
                
                selectedCube.position.x = targetPos.x;
                selectedCube.position.z = targetPos.z;
                
                // Auto-stack in VR too
                const targetHeight = getStackHeightAtPosition(targetPos.x, targetPos.z, selectedCube);
                selectedCube.position.y = Math.max(targetHeight, targetPos.y);
                
                // Visual feedback for VR stacking
                updateStackingFeedback(targetPos.x, targetPos.z, selectedCube);
            }
            
            // Add gentle floating animation to unplaced cubes
            if (!gameWon) {
                const time = Date.now() * 0.001;
                cubes.forEach((cube, index) => {
                    if (!cube.userData.isGrabbed) {
                        // Check if cube is not in a brick position
                        const inBrickPosition = BRICK_POSITIONS.some(pos => 
                            Math.abs(cube.position.x - pos.x) < 0.1 &&
                            Math.abs(cube.position.z - pos.z) < 0.1
                        );
                        
                        if (!inBrickPosition) {
                            cube.rotation.x = Math.sin(time + index) * 0.02;
                            cube.rotation.y = Math.cos(time + index * 0.7) * 0.02;
                        }
                    }
                });
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>