<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>WebXR Brick Building Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    body {
      margin: 0;
      background: #F7F4EA; /* linen */
      color: #1B1A17;
      font-family: Arial, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    #uiOverlay {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 1000;
      background: rgba(247, 244, 234, 0.80); /* #F7F4EA */
      border: 1px solid rgba(184, 124, 76, 0.35); /* #B87C4C */
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      padding: 12px 14px;
      border-radius: 12px;
      max-width: 320px;
      line-height: 1.3;
    }
    #uiOverlay h2 {
      margin: 0 0 8px;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.2px;
      color: #B87C4C;
    }
    #scoreDisplay, #moveDisplay, #timeDisplay {
      font-size: 14px;
      color: #1B1A17;
      margin: 4px 0;
      opacity: 0.95;
    }
    #helpOverlay {
      position: absolute;
      bottom: 12px;
      left: 12px;
      z-index: 1000;
      background: rgba(235, 217, 209, 0.85); /* #EBD9D1 */
      border: 1px solid rgba(184, 124, 76, 0.35); /* #B87C4C */
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      padding: 10px 12px;
      border-radius: 12px;
      max-width: 420px;
      font-size: 13px;
      color: #1B1A17;
    }
    #vrButton, #resetButton, #helpButton {
      position: absolute;
      right: 20px;
      padding: 10px 18px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      cursor: pointer;
      color: #F7F4EA; /* light text */
      background: #B87C4C; /* clay */
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
      transition: transform .08s ease, opacity .15s ease;
    }
    #vrButton:hover, #resetButton:hover, #helpButton:hover {
      transform: translateY(-1px);
      opacity: 0.95;
    }
    #vrButton { bottom: 20px; }
    #resetButton { bottom: 66px; }
    #helpButton { bottom: 112px; }

    #status {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1000;
      background: rgba(247, 244, 234, 0.80); /* #F7F4EA */
      border: 1px solid rgba(184, 124, 76, 0.35); /* #B87C4C */
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
      color: #1B1A17;
      min-width: 180px;
      text-align: right;
    }
    #status .progress {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 180px;
    }
    #status .progress__label {
      font-size: 12px;
      letter-spacing: 0.2px;
      color: #1B1A17;
      opacity: 0.95;
      text-align: right;
    }
    #status .progress__track {
      position: relative;
      height: 8px;
      border-radius: 999px;
      background: rgba(168,187,163,0.25); /* #A8BBA3 */
      overflow: hidden;
    }
    #status .progress__bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #A8BBA3, #B87C4C);
      border-radius: 999px;
      transition: width 180ms ease;
    }
    .toast {
      position: absolute;
      left: 50%;
      top: 72px;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(235, 217, 209, 0.92); /* #EBD9D1 */
      border: 1px solid rgba(184, 124, 76, 0.35);
      padding: 12px 16px;
      border-radius: 12px;
      max-width: 320px;
      font-size: 14px;
      color: #1B1A17;
    }
  </style>
</head>
<body>
  <div id="uiOverlay">
    <h2>Brick Stacker</h2>
    <div id="scoreDisplay"></div>
    <div id="moveDisplay"></div>
    <div id="timeDisplay"></div>
  </div>

  <div id="helpOverlay">
    <strong>Goal:</strong> stack all bricks into the glowing slots<br>
    <strong>Note:</strong> only one row of slots is visible at a time, finish a row to unlock the next<br>
    <strong>VR:</strong> point and squeeze trigger to grab, release to snap<br>
    <strong>Desktop, move camera:</strong> right drag to orbit, middle drag to pan, scroll to zoom<br>
    <strong>Desktop, move bricks:</strong> left click and drag to move a brick<br>
    <strong>Mobile:</strong> tap and drag to move a brick<br>
    <strong>Tip:</strong> slots light up when you are close
  </div>

  <button id="vrButton">Enter VR</button>
  <button id="resetButton">New Game</button>
  <button id="helpButton">Help</button>
  <div id="status"></div>

  <script>
    // Dimensions and layout
    const BRICK_W = 0.4, BRICK_H = 0.175, BRICK_D = 0.2;
    const ROW1_Y = BRICK_H / 2;     // base row center height
    const GAP_Y  = 0.05;            // small visual gap between rows
    // Grid config
    const ROWS = 5;                 // 5 rows
    const COLS = 8;                 // 8 bricks per row
    const GAP_X = 0.05;             // small horizontal gap between bricks
    const WALL_Z = -1.5;
    let BRICK_POSITIONS = [];

    function rebuildBrickPositions() {
      BRICK_POSITIONS = [];
      const startX = -((COLS - 1) / 2) * (BRICK_W + GAP_X);
      for (let r = 0; r < ROWS; r++) {
        const y = ROW1_Y + r * (BRICK_H + GAP_Y);
        for (let c = 0; c < COLS; c++) {
          const offset = (r % 2 === 1) ? (BRICK_W / 2) : 0; // stagger odd rows right by half a brick
          const x = startX + c * (BRICK_W + GAP_X) + offset;
          BRICK_POSITIONS.push({ x, y, z: WALL_Z });
        }
      }
    }

    // Marker visuals
    const MARKER_NORMAL   = { color: 0xEBD9D1, opacity: 0.35 }; // rose sand
    const MARKER_HOVER    = { color: 0xB87C4C, opacity: 0.75 }; // clay
    const MARKER_OCCUPIED = { color: 0xA8BBA3, opacity: 0.85 }; // sage

    let scene, camera, renderer, cubes = [], controllers = [];
    let controls = null;
    let selectedCube = null, selectedController = null;
    let gridMarkers = [], hoverValidIndex = null;
    let isMobile = false;

    // Scoring and progress
    let score = 0, gamesPlayed = 0, startTime = 0, moves = 0, bricksPlaced = 0, currentBrickNumber = 1;
    let TOTAL_BRICKS = ROWS * COLS; // 40
    let activeRow = 0; // only this row's empty slots are visible

    function renderStatusUI() {
      const s = document.getElementById('status');
      s.innerHTML = `
        <div class="progress" role="progressbar" aria-valuemin="0" aria-valuemax="${TOTAL_BRICKS}" aria-valuenow="0" aria-label="Wall progress">
          <div class="progress__label">0 / ${TOTAL_BRICKS} bricks</div>
          <div class="progress__track"><div class="progress__bar" style="width:0%"></div></div>
        </div>
      `;
    }

    function updateProgress() {
      const now = Math.min(TOTAL_BRICKS, Math.max(0, bricksPlaced));
      const pct = (now / TOTAL_BRICKS) * 100;
      const statusEl = document.getElementById('status');
      const bar = statusEl.querySelector('.progress__bar');
      const label = statusEl.querySelector('.progress__label');
      if (bar) bar.style.width = pct + '%';
      if (label) label.textContent = `${now} / ${TOTAL_BRICKS} bricks`;
      const pr = statusEl.querySelector('.progress');
      if (pr) pr.setAttribute('aria-valuenow', String(now));
    }

    function init() {
      isMobile = /Mobi|Android/i.test(navigator.userAgent);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // sky blue

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 1, 1.8);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Desktop camera controls
      if (!isMobile) {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.rotateSpeed = 0.9;
        controls.zoomSpeed = 1.0;
        controls.panSpeed = 0.8;
        controls.enableKeys = false;
        controls.screenSpacePanning = true;
        // reserve left click for bricks, right for orbit, middle for pan
        controls.mouseButtons = { LEFT: null, RIGHT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.PAN };
        const wallCenterY = ROW1_Y + (ROWS - 1) * (BRICK_H + GAP_Y) * 0.5;
        controls.target.set(0, wallCenterY, WALL_Z);
        controls.minDistance = 0.8;
        controls.maxDistance = 6;
        controls.update();
      }
      if (renderer && renderer.xr) {
        renderer.xr.addEventListener && renderer.xr.addEventListener('sessionstart', () => { if (controls) controls.enabled = false; });
        renderer.xr.addEventListener && renderer.xr.addEventListener('sessionend',   () => { if (controls) controls.enabled = true;  });
      }

      const hemiLight = new THREE.HemisphereLight(0xF7F4EA, 0xA8BBA3, 0.6);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xFFFFFF, 0.9);
      dirLight.position.set(2, 3, 1.5);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 1024;
      dirLight.shadow.mapSize.height = 1024;
      dirLight.shadow.camera.near = 0.5;
      dirLight.shadow.camera.far = 10;
      dirLight.shadow.bias = -0.0005;
      scene.add(dirLight);

      // Floor
      const floorGeo = new THREE.PlaneGeometry(20, 20);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xF7F4EA, roughness: 0.95, metalness: 0.0 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -0.5;
      floor.receiveShadow = true;
      scene.add(floor);

      // Wall markers
      rebuildBrickPositions();
      createGridMarkers();
      activeRow = 0;
      setRowVisibility(activeRow);

      // Visual boundaries and helper text
      createMovementBoundaries();
      createVRInstructions();

      // Bricks
      createCubes();

      // Input
      setupControllers();
      setupVRButton();
      if (isMobile) setupTouchControls(); else setupPointerControls();

      // UI
      updateScoreDisplay();
      renderStatusUI();
      updateProgress();

      window.addEventListener('resize', onWindowResize);
      renderer.setAnimationLoop(render);
    }

    function updateScoreDisplay() {
      document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
      document.getElementById('moveDisplay').textContent = `Moves: ${moves}`;
      const t = Math.floor((Date.now() - startTime) / 1000);
      document.getElementById('timeDisplay').textContent = `Time: ${t}s`;
    }

    function createGridMarkers() {
      gridMarkers = [];
      BRICK_POSITIONS.forEach((pos, index) => {
        const markerGeometry = new THREE.PlaneGeometry(BRICK_W, BRICK_D);
        const markerMaterial = new THREE.MeshBasicMaterial({
          color: MARKER_NORMAL.color,
          transparent: true,
          opacity: MARKER_NORMAL.opacity,
          side: THREE.DoubleSide
        });
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.rotation.x = -Math.PI / 2;
        marker.position.set(pos.x, pos.y - (BRICK_H / 2) - 0.01, pos.z);
        marker.userData = { index, occupied: false };
        scene.add(marker);
        gridMarkers.push(marker);
      });
    }

    /* row visibility + completeness */
    function setRowVisibility(row) {
      gridMarkers.forEach((m, i) => {
        const r = Math.floor(i / COLS);
        if (m.userData.occupied) {
          m.visible = false; // hide marker under placed bricks
        } else {
          m.visible = (r === row); // show only current row
        }
        if (m.visible) {
          m.material.color.setHex(MARKER_NORMAL.color);
          m.material.opacity = MARKER_NORMAL.opacity;
        }
      });
    }
    function isRowComplete(row) {
      const start = row * COLS;
      for (let i = 0; i < COLS; i++) {
        const m = gridMarkers[start + i];
        if (!m || !m.userData.occupied) return false;
      }
      return true;
    }
    function recomputeActiveRow() {
      let r = 0;
      while (r < ROWS && isRowComplete(r)) r++;
      activeRow = Math.min(r, ROWS - 1);
      setRowVisibility(activeRow);
    }

    function createMovementBoundaries() {
      const geo = new THREE.RingGeometry(1.4, 1.42, 64);
      const mat = new THREE.MeshBasicMaterial({ color: 0x556B6F, transparent: true, opacity: 0.2 });
      const ring = new THREE.Mesh(geo, mat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = -0.49;
      scene.add(ring);
    }

    function createVRInstructions() {
      const panelGeometry = new THREE.PlaneGeometry(0.6, 0.28);
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#1B1A17';
      ctx.fillRect(0, 0, 512, 256);
      ctx.fillStyle = '#EDE7E0';
      ctx.font = 'bold 22px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Place bricks on glowing slots', 256, 95);
      ctx.font = '18px Arial';
      ctx.fillText('Grab with trigger, release to snap', 256, 150);
      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
      const mesh = new THREE.Mesh(panelGeometry, mat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.set(0, -0.49, -0.6);
      scene.add(mesh);
    }

    function createCubes() {
      cubes = [];
      bricksPlaced = 0;
      currentBrickNumber = 1;
      moves = 0;
      startTime = Date.now();

      spawnNextBrick();
      updateScoreDisplay();
      updateProgress();
    }

    function clearBricksAndMarkers() {
      if (cubes && cubes.length) {
        cubes.forEach(b => {
          if (!b) return;
          scene.remove(b);
          if (b.geometry) b.geometry.dispose();
          if (b.material) {
            if (Array.isArray(b.material)) b.material.forEach(m => m && m.map && m.map.dispose());
            else if (b.material.map) b.material.map.dispose();
          }
        });
      }
      cubes = [];
      if (gridMarkers && gridMarkers.length) {
        gridMarkers.forEach(m => {
          if (!m) return;
          scene.remove(m);
          if (m.geometry) m.geometry.dispose();
          if (m.material) m.material.dispose();
        });
      }
      gridMarkers = [];
    }

    function resetGame() {
      hoverValidIndex = null;
      selectedCube = null;
      bricksPlaced = 0;
      currentBrickNumber = 1;
      moves = 0;
      startTime = Date.now();

      clearBricksAndMarkers();

      rebuildBrickPositions();
      TOTAL_BRICKS = ROWS * COLS;
      createGridMarkers();
      activeRow = 0;
      setRowVisibility(activeRow);

      spawnNextBrick();
      updateScoreDisplay();
      renderStatusUI();
      updateProgress();
      showToast('New game');
    }

    function addBrickGlow(brick) {
      const glowGeom = brick.geometry.clone();
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0x7A8F6A,
        transparent: true,
        opacity: 0.0,
        depthWrite: false
      });
      const glow = new THREE.Mesh(glowGeom, glowMat);
      glow.scale.set(1.06, 1.06, 1.06);
      glow.renderOrder = 999;
      brick.add(glow);
      brick.userData.glow = glow;
    }

    function setBrickGlow(brick, active) {
      if (!brick || !brick.userData) return;
      const glow = brick.userData.glow;
      if (!glow) return;
      const target = active ? 0.85 : 0.0;
      glow.material.opacity = glow.material.opacity + (target - glow.material.opacity) * 0.25;
      glow.visible = glow.material.opacity > 0.02;
    }

    function spawnNextBrick() {
      if (currentBrickNumber > TOTAL_BRICKS) return;

      const cubeColors = [
        { name: 'sage',      color: 0xA8BBA3, hexColor: '#A8BBA3' },
        { name: 'clay',      color: 0xB87C4C, hexColor: '#B87C4C' },
        { name: 'linen',     color: 0xF7F4EA, hexColor: '#F7F4EA' },
        { name: 'rose-sand', color: 0xEBD9D1, hexColor: '#EBD9D1' },
        { name: 'sage-2',    color: 0x9DB29A, hexColor: '#9DB29A' },
        { name: 'clay-2',    color: 0xA06E45, hexColor: '#A06E45' }
      ];
      const colorData = cubeColors[(currentBrickNumber - 1) % cubeColors.length];

      // Solid coloured brick
      const material = new THREE.MeshStandardMaterial({ color: colorData.color, roughness: 0.9, metalness: 0.0 });
      const brick = new THREE.Mesh(new THREE.BoxGeometry(BRICK_W, BRICK_H, BRICK_D), material);
      addBrickGlow(brick);

      // Spawn to the left of the wall, still in view
      const jitterX = (Math.random() - 0.5) * 0.1;
      const jitterZ = (Math.random() - 0.5) * 0.1;
      const spawnX  = -2.6 + jitterX; // adjust further left if desired
      const spawnZ  = WALL_Z - 0.8 + jitterZ;
      brick.position.set(spawnX, ROW1_Y, spawnZ);

      brick.castShadow = true;
      brick.receiveShadow = true;
      brick.userData.number = currentBrickNumber;
      brick.userData.isPlaced = false;
      brick.userData.slotIndex = null;
      scene.add(brick);
      cubes.push(brick);
    }

    function releaseFromSlot(brick) {
      if (!brick || !brick.userData) return;
      if (brick.userData.isPlaced && brick.userData.slotIndex != null) {
        const idx = brick.userData.slotIndex;
        const marker = gridMarkers[idx];
        if (marker) {
          marker.userData.occupied = false;
          marker.visible = true; // show marker again for re-targeting
          marker.material.color.setHex(MARKER_NORMAL.color);
          marker.material.opacity = MARKER_NORMAL.opacity;
        }
        brick.userData.isPlaced = false;
        brick.userData.slotIndex = null;
        if (bricksPlaced > 0) {
          bricksPlaced--;
          updateProgress();
          recomputeActiveRow(); // re-evaluate which row should be active
        }
      }
    }

    // Desktop and mobile pointer controls
    let mouse = new THREE.Vector2();
    let raycaster = new THREE.Raycaster();

    // VR picking helpers
    const vrRaycaster = new THREE.Raycaster();
    const _tempMat4 = new THREE.Matrix4();
    const _tempVec3 = new THREE.Vector3();
    const HOLD_MIN  = 0.35;  // closest allowed distance
    const HOLD_MAX  = 2.0;   // farthest allowed distance
    const HOLD_SENS = 1.2;   // forward/back controller motion sensitivity

    function onSelectStart(event) {
      const controller = event.target;

      // Build a ray from controller forward
      vrRaycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      _tempMat4.extractRotation(controller.matrixWorld);
      vrRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(_tempMat4);

      // Only grab bricks not yet placed
      const candidates = cubes.filter(b => !b.userData.isPlaced);
      const hits = vrRaycaster.intersectObjects(candidates, false);
      if (hits.length > 0) {
        const brick = hits[0].object;
        controller.userData.grabbedBrick = brick;
        brick.userData.isGrabbed = true;

        // If previously placed, free slot and decrement progress
        releaseFromSlot(brick);

        controller.userData.holding = true;

        // Capture grab-time pose and baseline distance along forward
        const controllerPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
        const controllerRot = new THREE.Matrix4().extractRotation(controller.matrixWorld);
        const forwardAtGrab = new THREE.Vector3(0, 0, -1).applyMatrix4(controllerRot).normalize();

        const toBrick = brick.position.clone().sub(controllerPos);
        let baseDist = toBrick.dot(forwardAtGrab);
        baseDist = THREE.MathUtils.clamp(baseDist, HOLD_MIN, HOLD_MAX);

        controller.userData.holdBaseDist = baseDist;
        controller.userData.holdForward  = forwardAtGrab.clone();
        controller.userData.holdGrabPos  = controllerPos.clone();

        if (controller.userData.laserLine) controller.userData.laserLine.visible = true;

        if (controller.userData.triggerMesh) controller.userData.triggerMesh.material.emissive.setHex(0x88ccff);
      }
    }

    function onSelectEnd(event) {
      const controller = event.target;
      const brick = controller.userData.grabbedBrick;
      if (!brick) return;

      brick.userData.isGrabbed = false;
      controller.userData.holding = false;
      controller.userData.holdBaseDist = null;
      controller.userData.holdForward  = null;
      controller.userData.holdGrabPos  = null;

      if (controller.userData.laserLine) controller.userData.laserLine.visible = false;

      snapToBrickPosition(brick);

      if (controller.userData.triggerMesh) controller.userData.triggerMesh.material.emissive.setHex(0x000000);

      controller.userData.grabbedBrick = null;
    }

    function setupPointerControls() {
      window.addEventListener('pointerdown', onPointerDown, { passive: false });
      window.addEventListener('pointermove', onPointerMove, { passive: false });
      window.addEventListener('pointerup', onPointerUp, { passive: false });
    }

    function onPointerDown(event) {
      // left click for bricks, right/middle reserved for orbit/pan
      if (event.button !== 0) return;
      event.preventDefault();
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(cubes);
      if (intersects.length > 0) {
        selectedCube = intersects[0].object;
        selectedCube.userData.isGrabbed = true;
        releaseFromSlot(selectedCube);
        if (navigator.vibrate) navigator.vibrate(20);
      }
    }

    function onPointerMove(event) {
      if (!selectedCube) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      updateCubePosition();
    }

    function updateCubePosition() {
      if (!selectedCube) return;
      raycaster.setFromCamera(mouse, camera);

      const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersection = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersection);

      if (intersection) {
        selectedCube.position.x = intersection.x;
        selectedCube.position.z = intersection.z;
        selectedCube.position.y = Math.max(ROW1_Y, intersection.y);

        // Floor clamp
        const FLOOR_TOP = -0.5;
        const minCenterY = FLOOR_TOP + (BRICK_H / 2);
        if (selectedCube.position.y < minCenterY) selectedCube.position.y = minCenterY;

        highlightNearbyPositions(intersection.x, intersection.z);
        setBrickGlow(selectedCube, hoverValidIndex !== null);
      }
    }

    function onPointerUp() {
      if (selectedCube) {
        selectedCube.userData.isGrabbed = false;
        moves++;
        updateScoreDisplay();

        const snapped = snapToBrickPosition(selectedCube);
        if (snapped && navigator.vibrate) navigator.vibrate(80);

        selectedCube = null;
        checkWinCondition();
      }
    }

    function setupTouchControls() { setupPointerControls(); }

    // VR setup and UI buttons
    function setupVRButton() {
      const btn = document.getElementById('vrButton');
      btn.addEventListener('click', () => {
        if (navigator.xr) {
          navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] })
            .then(session => renderer.xr.setSession(session))
            .catch(console.warn);
        }
      });

      document.getElementById('resetButton').addEventListener('click', resetGame);
      document.getElementById('helpButton').addEventListener('click', () => {
        showToast('Place bricks onto the glowing slots. Finish a row to unlock the next.');
      });
    }

    function showToast(text, ms = 2200) {
      const t = document.createElement('div');
      t.className = 'toast';
      t.textContent = text;
      document.body.appendChild(t);
      setTimeout(() => t.remove(), ms);
    }

    function highlightNearbyPositions(x, z) {
      const threshold = 0.35;
      let best = { d: Infinity, m: null };
      gridMarkers.forEach(m => {
        if (!m.visible) return;
        if (m.userData.occupied) {
          m.material.color.setHex(MARKER_OCCUPIED.color);
          m.material.opacity = MARKER_OCCUPIED.opacity;
          return;
        }
        const dx = x - m.position.x;
        const dz = z - m.position.z;
        const d  = Math.hypot(dx, dz);
        if (d < threshold) {
          m.material.color.setHex(MARKER_HOVER.color);
          m.material.opacity = MARKER_HOVER.opacity;
          if (d < best.d) best = { d, m };
        } else {
          m.material.color.setHex(MARKER_NORMAL.color);
          m.material.opacity = MARKER_NORMAL.opacity;
        }
      });
      if (best.m) {
        best.m.material.opacity = Math.min(0.9, MARKER_HOVER.opacity + 0.15);
        hoverValidIndex = best.m.userData.index;
      } else {
        hoverValidIndex = null;
      }
    }

    function snapToBrickPosition(brick) {
      let bestPosition = null;
      let minDistance = Infinity;
      const SNAP_RADIUS = 0.35;

      BRICK_POSITIONS.forEach((pos, index) => {
        const marker = gridMarkers[index];
        if (!marker || !marker.visible || marker.userData.occupied) return;

        const distance = Math.hypot(brick.position.x - pos.x, brick.position.z - pos.z);
        if (distance < SNAP_RADIUS && distance < minDistance) {
          minDistance = distance;
          bestPosition = { ...pos, index };
        }
      });

      if (bestPosition) {
        brick.position.x = bestPosition.x;
        brick.position.y = bestPosition.y;
        brick.position.z = bestPosition.z;
        brick.userData.isPlaced = true;
        brick.userData.slotIndex = bestPosition.index;

        const marker = gridMarkers[bestPosition.index];
        if (marker) {
          marker.userData.occupied = true;
          marker.visible = false; // hide once filled
        }

        if (brick.userData && brick.userData.glow) {
          const glow = brick.userData.glow;
          brick.remove(glow);
          if (glow.geometry) glow.geometry.dispose();
          if (glow.material) glow.material.dispose();
          brick.userData.glow = null;
        }
        hoverValidIndex = null;

        bricksPlaced++;
        currentBrickNumber++;
        updateProgress();

        // If current row is now complete, unlock next row
        const placedRow = Math.floor(bestPosition.index / COLS);
        if (placedRow === activeRow && isRowComplete(activeRow)) {
          if (activeRow < ROWS - 1) {
            activeRow++;
            setRowVisibility(activeRow);
            showToast(`Row ${placedRow + 1} complete, next row unlocked`);
          }
        }

        if (bricksPlaced < TOTAL_BRICKS) {
          setTimeout(spawnNextBrick, 800);
        } else {
          onAllBricksPlaced();
        }
        return true;
      }
      return false;
    }

    function onAllBricksPlaced() {
      const elapsed = Math.max(1, Math.floor((Date.now() - startTime) / 1000));
      const timeBonus = Math.max(0, 60 - elapsed);
      const movesPenalty = Math.max(0, moves - TOTAL_BRICKS) * 8;
      const gameScore = Math.max(15, 150 + timeBonus - movesPenalty);

      score += gameScore;
      gamesPlayed++;
      showToast(`Nice, wall complete, +${gameScore} points`);
      updateScoreDisplay();
      updateProgress();
    }

    function setupControllers() {
      controllers.forEach(c => { try { c.removeFromParent(); } catch(e){} });
      controllers = [];

      function createSimpleControllerModel(controller) {
        const group = new THREE.Group();

        const grip = new THREE.Mesh(
          new THREE.CylinderGeometry(0.018, 0.022, 0.12, 18),
          new THREE.MeshStandardMaterial({ color: 0xF2F2F2, metalness: 0.05, roughness: 0.9 })
        );
        grip.rotation.z = Math.PI / 2;
        grip.position.set(0, -0.03, 0.02);
        group.add(grip);

        const head = new THREE.Mesh(
          new THREE.TorusGeometry(0.04, 0.011, 16, 24),
          new THREE.MeshStandardMaterial({ color: 0xF7F7F7, metalness: 0.05, roughness: 0.92 })
        );
        head.rotation.x = Math.PI / 2;
        head.position.set(0, 0.02, 0.0);
        group.add(head);

        const body = new THREE.Mesh(
          new THREE.BoxGeometry(0.06, 0.03, 0.06),
          new THREE.MeshStandardMaterial({ color: 0xE7E7E7, metalness: 0.05, roughness: 0.9 })
        );
        body.position.set(0, 0.01, -0.01);
        group.add(body);

        const trigger = new THREE.Mesh(
          new THREE.BoxGeometry(0.014, 0.02, 0.018),
          new THREE.MeshStandardMaterial({ color: 0xDCDCDC, emissive: 0x000000, metalness: 0.1, roughness: 0.7 })
        );
        trigger.position.set(0, 0.012, -0.05);
        group.add(trigger);
        controller.userData.triggerMesh = trigger;

        return group;
      }

      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        controller.userData.grabbedBrick = null;

        // Laser line, visible while grabbing
        const rayGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -1)
        ]);
        const rayMat = new THREE.LineBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.9 });
        const laser = new THREE.Line(rayGeom, rayMat);
        laser.visible = false;
        laser.name = 'laserLine';
        controller.add(laser);
        controller.userData.laserLine = laser;

        // Always-visible pointer ray for aiming
        const pointerGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -1.2)
        ]);
        const pointerMat = new THREE.LineBasicMaterial({ color: 0xff4040, transparent: true, opacity: 0.95 });
        const pointer = new THREE.Line(pointerGeom, pointerMat);
        pointer.name = 'pointerLine';
        controller.add(pointer);
        controller.userData.pointerLine = pointer;

        controller.addEventListener('selectstart', onSelectStart);
        controller.addEventListener('selectend', onSelectEnd);

        const model = createSimpleControllerModel(controller);
        model.position.y = -0.01;
        controller.add(model);

        scene.add(controller);
        controllers.push(controller);
      }
    }

    function render() {
      if (controls) controls.update();

      if (selectedCube && selectedController) {
        selectedCube.position.y = Math.max(ROW1_Y, selectedCube.position.y);
        highlightNearbyPositions(selectedCube.position.x, selectedCube.position.z);
        setBrickGlow(selectedCube, hoverValidIndex !== null);
      }

      // VR controllers: update held brick position and laser
      for (const controller of controllers) {
        const brick = controller.userData.grabbedBrick;
        const laser = controller.userData.laserLine;

        if (brick) {
          const controllerPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
          const controllerRot = new THREE.Matrix4().extractRotation(controller.matrixWorld);
          const forwardNow = new THREE.Vector3(0, 0, -1).applyMatrix4(controllerRot).normalize();

          const base = (controller.userData.holdBaseDist != null) ? controller.userData.holdBaseDist : 0.6;
          const grabPos = controller.userData.holdGrabPos || controllerPos;

          const moveVec = controllerPos.clone().sub(grabPos);
          const deltaAlongForward = moveVec.dot(forwardNow);
          const desiredDist = THREE.MathUtils.clamp(base + deltaAlongForward * 1.2, HOLD_MIN, HOLD_MAX);

          const targetWorld = controllerPos.clone().add(forwardNow.multiplyScalar(desiredDist));

          brick.position.lerp(targetWorld, 0.35);

          const uprightQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0));
          brick.quaternion.slerp(uprightQuat, 0.25);

          _tempVec3.copy(brick.position);
          highlightNearbyPositions(_tempVec3.x, _tempVec3.z);
          setBrickGlow(brick, hoverValidIndex !== null);

          const dist = controllerPos.distanceTo(_tempVec3);
          if (laser) { laser.visible = true; laser.scale.z = Math.max(0.05, dist); }

          const FLOOR_TOP = -0.5;
          const minCenterY = FLOOR_TOP + (BRICK_H / 2);
          if (brick.position.y < minCenterY) brick.position.y = minCenterY;
        } else {
          if (laser) laser.visible = false;
        }
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function checkWinCondition() {
      // kept for future missions
    }

    function setupVRButtonOld(){} // noop guard if referenced somewhere else

    function setupVRButton() {
      const btn = document.getElementById('vrButton');
      btn.addEventListener('click', () => {
        if (navigator.xr) {
          navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] })
            .then(session => renderer.xr.setSession(session))
            .catch(console.warn);
        }
      });
      document.getElementById('resetButton').addEventListener('click', resetGame);
      document.getElementById('helpButton').addEventListener('click', () => {
        showToast('Finish each row to unlock the next.');
      });
    }

    // Go
    init();

  </script>
</body>
</html>