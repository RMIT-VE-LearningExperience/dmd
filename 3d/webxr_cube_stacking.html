<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Brick Building Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 280px;
            font-size: 14px;
        }
        
        #vrButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }
        
        #vrButton:hover {
            background: #45a049;
        }
        
        #vrButton:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            max-width: 400px;
        }
        
        #resetButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 12px 24px;
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }
        
        #resetScoreButton {
            position: absolute;
            bottom: 70px;
            left: 20px;
            padding: 8px 16px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            z-index: 1000;
        }
        
        .brick-pattern {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            margin: 8px 0;
        }
        
        .brick-row {
            display: flex;
            gap: 1px;
        }
        
        .brick-row.offset {
            transform: translateX(15px); /* Offset second row */
        }
        
        .brick-cell {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            padding: 4px 8px;
            text-align: center;
            border-radius: 3px;
            font-size: 12px;
            min-width: 30px;
        }
        
        @media (max-width: 768px) {
            #info {
                font-size: 12px;
                padding: 10px;
                max-width: 250px;
            }
            
            #vrButton {
                bottom: 10px;
                right: 10px;
                padding: 10px 20px;
                font-size: 14px;
            }
            
            #resetButton {
                bottom: 10px;
                left: 10px;
                padding: 10px 20px;
                font-size: 14px;
            }
            
            #resetScoreButton {
                bottom: 60px;
                left: 10px;
                padding: 6px 12px;
                font-size: 12px;
            }
            
            #status {
                font-size: 16px;
                padding: 15px;
                max-width: 300px;
            }
            
            .brick-cell {
                font-size: 10px;
                padding: 2px;
            }
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸ§± Brick Wall Building Game</h3>
        <div id="targetOrder" style="font-size: 14px; margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
            <strong>Target: Staggered Brick Wall:</strong>
            <div id="brickDisplay" class="brick-pattern">
                <div class="brick-row">
                    <div class="brick-cell">ðŸ§±</div>
                    <div class="brick-cell">ðŸ§±</div>
                    <div class="brick-cell">ðŸ§±</div>
                </div>
                <div class="brick-row offset">
                    <div class="brick-cell">ðŸ§±</div>
                    <div class="brick-cell">ðŸ§±</div>
                    <div class="brick-cell">ðŸ§±</div>
                </div>
            </div>
            <small style="color: #aaa;">â†‘ Classic staggered pattern - one brick at a time!</small>
        </div>
        <div id="scoreBoard" style="font-size: 14px; margin: 10px 0;">
            <strong>Score:</strong> <span id="currentScore">0</span> | 
            <strong>Games:</strong> <span id="gamesCount">0</span> |
            <strong>Moves:</strong> <span id="movesCount">0</span><br>
            <strong>Progress:</strong> <span id="bricksProgress">0/6 bricks placed</span>
        </div>
        <p><strong>Goal:</strong> Build a staggered brick wall - one brick at a time!</p>
        <p><strong>VR:</strong> Point and squeeze trigger<br>
        <strong>Desktop:</strong> Click and drag<br>
        <strong>Mobile:</strong> Tap and drag</p>
        <p><strong>System:</strong> Place each brick to spawn the next one!</p>
    </div>
    
    <button id="vrButton">Enter VR</button>
    <button id="resetButton">New Game</button>
    <button id="resetScoreButton">Reset Score</button>
    <div id="status"></div>

    <script>
        let scene, camera, renderer, cubes = [], controllers = [];
        let selectedCube = null, selectedController = null;
        let gameWon = false;
        let TARGET_ARRANGEMENT = [
            { number: 1, color: '#ff4757', emoji: 'ðŸ”´' },
            { number: 2, color: '#2ed573', emoji: 'ðŸŸ¢' },
            { number: 3, color: '#3742fa', emoji: 'ðŸ”µ' },
            { number: 4, color: '#ffa502', emoji: 'ðŸŸ¡' },
            { number: 5, color: '#ff6348', emoji: 'ðŸŸ ' },
            { number: 6, color: '#9c88ff', emoji: 'ðŸŸ£' }
        ]; // Always in numerical order 1-6
        let isMobile = false;
        let touchStartPos = null;
        
        // Scoring system
        let score = 0;
        let gamesPlayed = 0;
        let startTime = 0;
        let moves = 0;
        let bricksPlaced = 0;
        let currentBrickNumber = 1;
        
        // Realistic brick wall positions (running bond pattern)
        const BRICK_POSITIONS = [
            // Bottom row (3 bricks, no gaps)
            { x: -0.8, y: 0.175, z: -1.5, row: 0, col: 0 },
            { x: 0, y: 0.175, z: -1.5, row: 0, col: 1 },
            { x: 0.8, y: 0.175, z: -1.5, row: 0, col: 2 },
            // Top row (offset by half brick = 0.4, creating staggered pattern)
            { x: -0.4, y: 0.525, z: -1.5, row: 1, col: 0 },
            { x: 0.4, y: 0.525, z: -1.5, row: 1, col: 1 },
            { x: 1.2, y: 0.525, z: -1.5, row: 1, col: 2 }
        ];
        
        // Raycaster for mouse/controller interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Detect mobile devices
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                  ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        
        init();
        animate();
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 2.5); // Moved back for better VR view
            
            // Renderer with XR support
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Floor with better appearance
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d4a4a,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.5;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create grid markers for brick positions
            createGridMarkers();
            
            // Create movement boundary markers for VR
            createMovementBoundaries();
            
            // Create VR instruction panels
            createVRInstructions();
            
            // Create cubes
            createCubes();
            
            // Setup VR controllers
            setupControllers();
            
            // Setup VR button
            setupVRButton();
            
            // Setup controls based on device
            if (isMobile) {
                setupTouchControls();
            } else {
                setupMouseControls();
            }
            
            // Reset button
            setupResetButton();
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Instructions
            showInstructions();
        }
        
        function createVRInstructions() {
            // Instructions will be attached to left controller dynamically
            // This function now just creates the template
        }
        
        function attachInstructionsToController(controller, isLeftHand = true) {
            // Remove any existing instructions on this controller
            const existingInstructions = controller.getObjectByName('controllerInstructions');
            if (existingInstructions) {
                controller.remove(existingInstructions);
            }
            
            // Create floating instruction panel attached to left controller
            const instructionsGroup = new THREE.Group();
            instructionsGroup.name = 'controllerInstructions';
            
            // Background panel (smaller for hand attachment)
            const panelGeometry = new THREE.PlaneGeometry(0.3, 0.2);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.8 
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            
            // Position relative to controller (above and slightly forward)
            instructionsGroup.position.set(0, 0.15, -0.1);
            instructionsGroup.rotation.x = -Math.PI / 6; // Tilt toward user
            instructionsGroup.add(panel);
            
            // Create text texture for instructions
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 160;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, 256, 160);
            
            // Border
            context.strokeStyle = '#00ff88';
            context.lineWidth = 3;
            context.strokeRect(0, 0, 256, 160);
            
            // Text
            context.fillStyle = '#ffffff';
            context.font = '14px Arial';
            context.textAlign = 'center';
            context.fillText('ðŸ§± Staggered Bricks', 128, 20);
            context.font = '11px Arial';
            context.fillText('Build realistic wall', 128, 40);
            context.fillText('One brick at a time!', 128, 55);
            context.fillText('Joystick: Move around', 128, 75);
            context.fillText('Trigger: Grab brick', 128, 90);
            context.fillText('Place to spawn next', 128, 105);
            context.font = '9px Arial';
            context.fillText('Score: Speed + Efficiency', 128, 125);
            context.fillText('Progress on this hand!', 128, 140);
            
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture });
            const textMesh = new THREE.Mesh(panelGeometry, textMaterial);
            textMesh.position.z = 0.001; // Slightly in front of background
            
            instructionsGroup.add(textMesh);
            controller.add(instructionsGroup);
            
            return instructionsGroup;
        }
        
        function createVRStatusPanel(message, color = '#ffffff', duration = 3000) {
            // Remove existing status panel
            const existingPanel = scene.getObjectByName('vrStatusPanel');
            if (existingPanel) {
                scene.remove(existingPanel);
            }
            
            const statusGroup = new THREE.Group();
            statusGroup.name = 'vrStatusPanel';
            
            // Background panel
            const panelGeometry = new THREE.PlaneGeometry(2.5, 1);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.9 
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            
            // Position status in front of player
            statusGroup.position.set(0, 1.8, -1.2);
            statusGroup.add(panel);
            
            // Create text texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 200;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, 512, 200);
            
            // Border
            context.strokeStyle = color;
            context.lineWidth = 6;
            context.strokeRect(0, 0, 512, 200);
            
            // Text
            context.fillStyle = color;
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Split message into lines
            const lines = message.split('<br>');
            const lineHeight = 40;
            const startY = 100 - (lines.length - 1) * lineHeight / 2;
            
            lines.forEach((line, index) => {
                // Remove HTML tags for canvas rendering
                const cleanLine = line.replace(/<[^>]*>/g, '');
                context.fillText(cleanLine, 256, startY + index * lineHeight);
            });
            
            const textTexture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture });
            const textMesh = new THREE.Mesh(panelGeometry, textMaterial);
            textMesh.position.z = 0.01;
            
            statusGroup.add(textMesh);
            scene.add(statusGroup);
            
            // Auto-remove after duration
            setTimeout(() => {
                const panel = scene.getObjectByName('vrStatusPanel');
                if (panel) {
                    scene.remove(panel);
                }
            }, duration);
        }
        
        function createGridMarkers() {
            // Create subtle grid markers to show where cubes should go
            BRICK_POSITIONS.forEach((pos, index) => {
                const markerGeometry = new THREE.PlaneGeometry(0.4, 0.4);
                const markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.3
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.rotation.x = -Math.PI / 2;
                marker.position.set(pos.x, pos.y - 0.24, pos.z);
                scene.add(marker);
            });
        }
        
        function createMovementBoundaries() {
            // Create subtle boundary markers to show movement area in VR
            const boundaryGeometry = new THREE.RingGeometry(4.5, 5, 16);
            const boundaryMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const boundaryMarker = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            boundaryMarker.rotation.x = -Math.PI / 2;
            boundaryMarker.position.y = -0.48;
            boundaryMarker.name = 'movementBoundary';
            scene.add(boundaryMarker);
        }
        
        function createNumberTexture(number, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = color;
            context.fillRect(0, 0, 128, 128);
            
            // Border
            context.strokeStyle = '#000000';
            context.lineWidth = 4;
            context.strokeRect(0, 0, 128, 128);
            
            // Number
            context.fillStyle = '#000000';
            context.font = 'bold 80px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(number.toString(), 64, 64);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function updateTargetDisplay() {
            // The staggered pattern is now shown directly in the HTML
            console.log('Staggered brick wall pattern - one brick spawns at a time!');
        }
        
        function updateScoreDisplay() {
            document.getElementById('currentScore').textContent = score;
            document.getElementById('gamesCount').textContent = gamesPlayed;
            document.getElementById('movesCount').textContent = moves;
            document.getElementById('bricksProgress').textContent = `${bricksPlaced}/6 bricks placed`;
        }
        
        function calculateScore(timeBonus, movesPenalty) {
            // Base score: 150 points (more complex game)
            // Time bonus: up to 75 points (faster = more points)
            // Move penalty: -8 points per move over 6
            let gameScore = 150 + timeBonus - movesPenalty;
            return Math.max(gameScore, 15); // Minimum 15 points
        }
        
        function createCubes() {
            cubes = []; // Clear existing cubes
            bricksPlaced = 0;
            currentBrickNumber = 1;
            
            gameWon = false;
            moves = 0;
            startTime = Date.now();
            
            // Spawn only the first brick
            spawnNextBrick();
            
            // Update display
            updateTargetDisplay();
            updateScoreDisplay();
        }
        
        function spawnNextBrick() {
            if (currentBrickNumber > 6) return; // All bricks spawned
            
            const cubeColors = [
                { name: 'red', color: 0xff4757, hexColor: '#ff4757' },
                { name: 'green', color: 0x2ed573, hexColor: '#2ed573' },
                { name: 'blue', color: 0x3742fa, hexColor: '#3742fa' },
                { name: 'yellow', color: 0xffa502, hexColor: '#ffa502' },
                { name: 'orange', color: 0xff6348, hexColor: '#ff6348' },
                { name: 'purple', color: 0x9c88ff, hexColor: '#9c88ff' }
            ];
            
            const brickGeometry = new THREE.BoxGeometry(0.8, 0.35, 0.4);
            const colorData = cubeColors[currentBrickNumber - 1];
            
            // Create materials for each face with numbers
            const materials = [];
            for (let i = 0; i < 6; i++) {
                const texture = createNumberTexture(currentBrickNumber, colorData.hexColor);
                materials.push(new THREE.MeshLambertMaterial({ map: texture }));
            }
            
            const brick = new THREE.Mesh(brickGeometry, materials);
            
            // Position new brick in front of player (random position in spawn area)
            const spawnAngle = Math.random() * Math.PI/2 + Math.PI/4; // 45Â° to 135Â° arc
            const spawnRadius = 1.2 + Math.random() * 0.4; // 1.2-1.6 meters from player
            
            const spawnX = Math.cos(spawnAngle) * spawnRadius;
            const spawnZ = Math.sin(spawnAngle) * spawnRadius - 0.3;
            
            brick.position.set(spawnX, 0.175, spawnZ);
            brick.castShadow = true;
            brick.receiveShadow = true;
            
            brick.userData = {
                number: currentBrickNumber,
                colorName: colorData.name,
                originalPosition: brick.position.clone(),
                isGrabbed: false,
                isPlaced: false
            };
            
            scene.add(brick);
            cubes.push(brick);
            
            // Show spawn notification in VR
            if (renderer.xr.getSession()) {
                createVRStatusPanel(
                    `Brick ${currentBrickNumber} spawned!<br>Pick it up and place it<br>${6 - bricksPlaced} bricks remaining`, 
                    '#00aaff', 
                    2000
                );
            }
            
            console.log(`Spawned brick ${currentBrickNumber}`);
        }
        
        function getStackHeightAtPosition(x, z, excludeCube) {
            let maxHeight = 0.175; // Start with one brick height
            const tolerance = 0.4; // How close bricks need to be to stack
            
            cubes.forEach(cube => {
                if (cube === excludeCube) return;
                
                const distance = Math.sqrt(
                    Math.pow(cube.position.x - x, 2) + 
                    Math.pow(cube.position.z - z, 2)
                );
                
                if (distance < tolerance) {
                    maxHeight = Math.max(maxHeight, cube.position.y + 0.35); // Brick height
                }
            });
            
            return maxHeight;
        }
        
        function updateStackingFeedback(x, z, excludeCube) {
            // Reset all cube materials
            cubes.forEach(cube => {
                if (cube !== excludeCube && !cube.userData.isGrabbed) {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x000000);
                    });
                }
            });
            
            // Highlight cubes that would be stacked on
            const tolerance = 0.4;
            cubes.forEach(cube => {
                if (cube === excludeCube) return;
                
                const distance = Math.sqrt(
                    Math.pow(cube.position.x - x, 2) + 
                    Math.pow(cube.position.z - z, 2)
                );
                
                if (distance < tolerance) {
                    cube.material.forEach(mat => {
                        mat.emissive.setHex(0x111111);
                    });
                }
            });
        }
        
        function snapToBrickPosition(brick) {
            if (brick.userData.isPlaced) return false; // Already placed
            
            let bestPosition = null;
            let minDistance = Infinity;
            
            // Find the closest available brick position
            BRICK_POSITIONS.forEach((pos, index) => {
                const distance = Math.sqrt(
                    (brick.position.x - pos.x) ** 2 + 
                    (brick.position.z - pos.z) ** 2
                );
                
                if (distance < minDistance && distance < 0.6) { // Snapping range for bricks
                    // Check if this position is already occupied
                    const occupied = cubes.some(otherBrick => 
                        otherBrick !== brick &&
                        otherBrick.userData.isPlaced &&
                        Math.abs(otherBrick.position.x - pos.x) < 0.2 &&
                        Math.abs(otherBrick.position.z - pos.z) < 0.2
                    );
                    
                    if (!occupied) {
                        minDistance = distance;
                        bestPosition = { ...pos, index };
                    }
                }
            });
            
            if (bestPosition) {
                brick.position.x = bestPosition.x;
                brick.position.y = bestPosition.y;
                brick.position.z = bestPosition.z;
                brick.userData.isPlaced = true;
                
                bricksPlaced++;
                currentBrickNumber++;
                
                // Spawn next brick if we haven't placed all 6 yet
                if (bricksPlaced < 6) {
                    setTimeout(() => {
                        spawnNextBrick();
                    }, 1000); // Small delay for better UX
                }
                
                console.log(`Brick placed! ${bricksPlaced}/6 complete`);
                return true;
            }
            return false;
        }
        
        function setupControllers() {
            // Setup VR controllers with simple visuals and locomotion
            controllers = []; // Clear any existing controllers
            
            for (let i = 0; i < 2; i++) {
                try {
                    const controller = renderer.xr.getController(i);
                    const controllerGrip = renderer.xr.getControllerGrip(i);
                    
                    // Add event listeners
                    controller.addEventListener('selectstart', onSelectStart);
                    controller.addEventListener('selectend', onSelectEnd);
                    controller.addEventListener('connected', (event) => {
                        console.log(`Controller ${i} connected:`, event.data);
                        
                        // Attach instructions to left controller (typically index 0)
                        if (i === 0 || (event.data.handedness && event.data.handedness === 'left')) {
                            setTimeout(() => {
                                attachInstructionsToController(controller, true);
                            }, 500);
                        }
                    });
                    
                    // Add to scene
                    scene.add(controller);
                    scene.add(controllerGrip);
                    
                    // Create simple visual ray
                    const rayGeometry = new THREE.BufferGeometry();
                    const rayPositions = new Float32Array([
                        0, 0, 0,
                        0, 0, -1
                    ]);
                    rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
                    
                    const rayMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                    const rayLine = new THREE.Line(rayGeometry, rayMaterial);
                    rayLine.scale.z = 3;
                    controller.add(rayLine);
                    
                    // Simple controller handle visual
                    const handleGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.15);
                    const handleMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
                    const handleMesh = new THREE.Mesh(handleGeometry, handleMaterial);
                    controller.add(handleMesh);
                    
                    controllers.push({
                        controller: controller,
                        grip: controllerGrip,
                        index: i,
                        gamepad: null,
                        inputSource: null
                    });
                    
                } catch (error) {
                    console.log(`Controller ${i} setup failed:`, error);
                }
            }
            
            // Fallback: attach instructions to first controller after a delay
            setTimeout(() => {
                if (controllers.length > 0) {
                    attachInstructionsToController(controllers[0].controller, true);
                }
            }, 2000);
            
            console.log(`Initialized ${controllers.length} VR controllers with hand-attached instructions`);
        }
        
        function updateVRLocomotion() {
            if (!renderer.xr.getSession()) return;
            
            const session = renderer.xr.getSession();
            const referenceSpace = renderer.xr.getReferenceSpace();
            
            if (session && session.inputSources) {
                session.inputSources.forEach((inputSource, index) => {
                    if (inputSource.gamepad && controllers[index]) {
                        controllers[index].gamepad = inputSource.gamepad;
                        controllers[index].inputSource = inputSource;
                        
                        const gamepad = inputSource.gamepad;
                        
                        // Check for thumbstick input (usually axes 2,3 for right controller, 0,1 for left)
                        if (gamepad.axes.length >= 4) {
                            let moveX = 0;
                            let moveZ = 0;
                            
                            // Use left controller for movement (typically controller index 0)
                            if (index === 0) {
                                moveX = gamepad.axes[2]; // Left thumbstick X
                                moveZ = gamepad.axes[3]; // Left thumbstick Y
                            }
                            // Or right controller as backup
                            else if (index === 1 && Math.abs(gamepad.axes[2]) > 0.1 || Math.abs(gamepad.axes[3]) > 0.1) {
                                moveX = gamepad.axes[2]; // Right thumbstick X  
                                moveZ = gamepad.axes[3]; // Right thumbstick Y
                            }
                            
                            // Apply deadzone
                            const deadzone = 0.15;
                            if (Math.abs(moveX) < deadzone) moveX = 0;
                            if (Math.abs(moveZ) < deadzone) moveZ = 0;
                            
                            // Apply movement if thumbstick is being used
                            if (Math.abs(moveX) > 0 || Math.abs(moveZ) > 0) {
                                const speed = 0.02; // Movement speed
                                
                                // Get camera direction for forward movement
                                const cameraDirection = new THREE.Vector3();
                                camera.getWorldDirection(cameraDirection);
                                
                                // Create right vector
                                const rightVector = new THREE.Vector3();
                                rightVector.crossVectors(cameraDirection, camera.up).normalize();
                                
                                // Create forward vector (without Y component for ground movement)
                                const forwardVector = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
                                
                                // Calculate movement vector
                                const movement = new THREE.Vector3();
                                movement.addScaledVector(rightVector, moveX * speed);
                                movement.addScaledVector(forwardVector, -moveZ * speed); // Negative because forward is usually negative Z
                                
                                // Apply movement to camera/player position
                                const currentPosition = new THREE.Vector3();
                                camera.getWorldPosition(currentPosition);
                                currentPosition.add(movement);
                                
                                // Simple bounds checking (keep player in reasonable area)
                                const prevX = currentPosition.x;
                                const prevZ = currentPosition.z;
                                
                                currentPosition.x = Math.max(-5, Math.min(5, currentPosition.x));
                                currentPosition.z = Math.max(-3, Math.min(4, currentPosition.z));
                                currentPosition.y = Math.max(0.5, currentPosition.y); // Don't go below ground
                                
                                // Provide haptic feedback if hitting boundary
                                if ((prevX !== currentPosition.x || prevZ !== currentPosition.z) && 
                                    inputSource.hapticActuators && inputSource.hapticActuators[0]) {
                                    inputSource.hapticActuators[0].pulse(0.3, 100); // Light pulse at boundary
                                }
                                
                                // Apply the movement by offsetting the reference space
                                if (referenceSpace) {
                                    const offsetPosition = new THREE.Vector3().subVectors(currentPosition, camera.position);
                                    camera.position.copy(currentPosition);
                                }
                            }
                        }
                    }
                });
            }
        }
        
        function setupVRButton() {
            const vrButton = document.getElementById('vrButton');
            
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.addEventListener('click', () => {
                            if (renderer.xr.getSession()) {
                                renderer.xr.getSession().end();
                            } else {
                                navigator.xr.requestSession('immersive-vr', {
                                    requiredFeatures: ['local-floor'],
                                    optionalFeatures: ['hand-tracking', 'bounded-floor']
                                }).then((session) => {
                                    renderer.xr.setSession(session);
                                }).catch((error) => {
                                    console.log('VR session failed:', error);
                                    showStatus('VR session failed to start', 2000);
                                });
                            }
                        });
                    } else {
                        vrButton.textContent = 'VR Not Supported';
                        vrButton.disabled = true;
                    }
                }).catch(() => {
                    vrButton.textContent = 'VR Not Available';
                    vrButton.disabled = true;
                });
            } else {
                vrButton.textContent = 'WebXR Not Available';
                vrButton.disabled = true;
            }
            
            renderer.xr.addEventListener('sessionstart', () => {
                vrButton.textContent = 'Exit VR';
                // Show VR welcome message
                setTimeout(() => {
                    createVRStatusPanel(
                        `Welcome to VR Mode!<br>Instructions attached to left hand<br>Use joystick to move around<br>Point & squeeze to grab brick<br>Build staggered wall!`, 
                        '#00ff88', 
                        5000
                    );
                }, 1000);
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                vrButton.textContent = 'Enter VR';
                // Clean up controller-attached instructions
                controllers.forEach(controllerObj => {
                    const instructions = controllerObj.controller.getObjectByName('controllerInstructions');
                    if (instructions) {
                        controllerObj.controller.remove(instructions);
                    }
                });
                // Clean up any floating status panels
                const vrStatus = scene.getObjectByName('vrStatusPanel');
                if (vrStatus) {
                    scene.remove(vrStatus);
                }
            });
        }
        
        function setupMouseControls() {
            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
        }
        
        function setupTouchControls() {
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
        }
        
        function setupResetButton() {
            document.getElementById('resetButton').addEventListener('click', resetGame);
            document.getElementById('resetScoreButton').addEventListener('click', resetScore);
        }
        
        function resetScore() {
            if (confirm('Reset your total score and start fresh?')) {
                score = 0;
                gamesPlayed = 0;
                updateScoreDisplay();
                showStatus('Score Reset! ðŸ”„', 1500);
            }
        }
        
        function resetGame() {
            // Remove existing cubes
            cubes.forEach(cube => scene.remove(cube));
            selectedCube = null;
            selectedController = null;
            
            // Recreate cubes (this will spawn only the first brick)
            createCubes();
            showStatus('New Staggered Brick Wall! ðŸ§±<br>Place each brick to spawn the next one!', 3000);
            
            // Show VR-specific reset message if in VR
            if (renderer.xr.getSession()) {
                createVRStatusPanel(
                    `New Staggered Wall!<br>Build classic brick pattern<br>One brick at a time<br>Let's build!`, 
                    '#ffaa00', 
                    3000
                );
            }
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            if (gameWon || renderer.xr.getSession()) return;
            
            const touch = event.touches[0];
            touchStartPos = { x: touch.clientX, y: touch.clientY };
            
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0) {
                selectedCube = intersects[0].object;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
                
                // Haptic feedback on mobile (if available)
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (gameWon || !selectedCube || renderer.xr.getSession()) return;
            
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            updateCubePosition();
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            onPointerUp();
        }
        
        function onPointerDown(event) {
            if (gameWon || renderer.xr.getSession()) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0) {
                selectedCube = intersects[0].object;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
            }
        }
        
        function onPointerMove(event) {
            if (gameWon || !selectedCube || renderer.xr.getSession()) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            updateCubePosition();
        }
        
        function updateCubePosition() {
            if (!selectedCube) return;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Project mouse position to a plane
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);
            
            if (intersection) {
                selectedCube.position.x = intersection.x;
                selectedCube.position.z = intersection.z;
                selectedCube.position.y = Math.max(0.175, intersection.y); // Keep at brick height
                
                // Add visual feedback for nearby brick positions
                highlightNearbyPositions(intersection.x, intersection.z);
            }
        }
        
        function highlightNearbyPositions(x, z) {
            // Could add highlighting for nearby brick positions
            // For now, keep it simple
        }
        
        function onPointerUp() {
            if (selectedCube) {
                selectedCube.userData.isGrabbed = false;
                
                // Clear highlighting
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x000000);
                });
                
                // Count this as a move
                moves++;
                updateScoreDisplay();
                
                // Try to snap to brick position
                const snapped = snapToBrickPosition(selectedCube);
                if (snapped) {
                    if (navigator.vibrate) {
                        navigator.vibrate(100); // Stronger feedback for successful placement
                    }
                }
                
                selectedCube = null;
                checkWinCondition();
                
                // Haptic feedback on mobile
                if (navigator.vibrate) {
                    navigator.vibrate(30);
                }
            }
        }
        
        function onSelectStart(event) {
            const controller = event.target;
            
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0 && !gameWon) {
                selectedCube = intersects[0].object;
                selectedController = controller;
                selectedCube.userData.isGrabbed = true;
                
                // Highlight selected cube
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x444444);
                });
            }
        }
        
        function onSelectEnd() {
            if (selectedCube) {
                selectedCube.userData.isGrabbed = false;
                
                // Clear highlighting
                selectedCube.material.forEach(mat => {
                    mat.emissive.setHex(0x000000);
                });
                
                // Count this as a move
                moves++;
                updateScoreDisplay();
                
                // Try to snap to brick position
                snapToBrickPosition(selectedCube);
                
                selectedCube = null;
                selectedController = null;
                checkWinCondition();
            }
        }
        
        function checkWinCondition() {
            // Win when all 6 bricks are placed in their positions
            if (bricksPlaced === 6) {
                winGame();
            }
        }
        
        function winGame() {
            gameWon = true;
            gamesPlayed++;
            
            // Calculate score
            const timeTaken = (Date.now() - startTime) / 1000; // seconds
            const timeBonus = Math.max(0, Math.floor(75 - timeTaken * 2)); // Up to 75 bonus points for speed
            const movesPenalty = Math.max(0, (moves - 6) * 8); // -8 points per move over 6
            const gameScore = calculateScore(timeBonus, movesPenalty);
            
            score += gameScore;
            updateScoreDisplay();
            
            // Show detailed win message
            const message = `ðŸ§± Perfect Brick Wall! You Won! ðŸ§±<br>
                           <strong>Game Score: ${gameScore} points</strong><br>
                           Time: ${timeTaken.toFixed(1)}s (${timeBonus > 0 ? '+' + timeBonus : '0'} bonus)<br>
                           Moves: ${moves} (${movesPenalty > 0 ? '-' + movesPenalty : '0'} penalty)<br>
                           <strong>Total Score: ${score}</strong>`;
            
            // Show message both in regular UI and VR
            showStatus(message, 5000);
            
            // Show VR-specific success message if in VR
            if (renderer.xr.getSession()) {
                createVRStatusPanel(
                    `ðŸŽ‰ VICTORY! ðŸŽ‰<br>Perfect Brick Wall Built!<br>Score: ${gameScore} points<br>Total: ${score} points`, 
                    '#00ff00', 
                    4000
                );
            }
            
            // Celebration effect - make all cubes glow
            cubes.forEach(cube => {
                cube.material.forEach(mat => {
                    mat.emissive.setHex(0x222222);
                });
            });
            
            // Victory haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100, 50, 200]);
            }
            
            // Auto-restart after a delay
            setTimeout(() => {
                if (gameWon) { // Only restart if user hasn't manually reset
                    resetGame();
                }
            }, 6000);
        }
        
        function showStatus(message, duration = 2000) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = message;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, duration);
        }
        
        function showInstructions() {
            setTimeout(() => {
                const device = isMobile ? 'Tap' : 'Click';
                const regularMessage = `${device} and drag bricks to build a staggered wall!<br>
                           <strong>System:</strong> Only one brick appears at a time<br>
                           <strong>Goal:</strong> Place it to spawn the next brick<br>
                           <strong>Pattern:</strong> Classic staggered brick layout<br>
                           <strong>Faster + Fewer moves = Higher score!</strong>`;
                
                showStatus(regularMessage, 8000);
                
                // Show VR-specific instructions if in VR
                if (renderer.xr.getSession()) {
                    createVRStatusPanel(
                        `Welcome to Staggered Building!<br>Use joystick to move around<br>Place each brick to get the next<br>Build classic brick pattern!<br>Good luck!`, 
                        '#00aaff', 
                        6000
                    );
                }
            }, 1000);
        }
        
        function animate() {
            renderer.setAnimationLoop(render);
        }
        
        function render() {
            // Update VR locomotion
            updateVRLocomotion();
            
            // Update grabbed cube position for VR controllers
            if (selectedCube && selectedController) {
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(selectedController.matrixWorld);
                
                const forward = new THREE.Vector3(0, 0, -0.8);
                forward.applyMatrix4(tempMatrix);
                
                const targetPos = selectedController.position.clone();
                targetPos.add(forward);
                
                selectedCube.position.x = targetPos.x;
                selectedCube.position.z = targetPos.z;
                selectedCube.position.y = Math.max(0.175, targetPos.y); // Keep at brick height
            }
            
            // Add gentle floating animation to unplaced cubes
            if (!gameWon) {
                const time = Date.now() * 0.001;
                cubes.forEach((cube, index) => {
                    if (!cube.userData.isGrabbed && !cube.userData.isPlaced) {
                        cube.rotation.x = Math.sin(time + index) * 0.02;
                        cube.rotation.y = Math.cos(time + index * 0.7) * 0.02;
                    }
                });
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>