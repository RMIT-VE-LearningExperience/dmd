<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebXR Excavator Viewer</title>
    <style>
      html, body { height: 100%; margin: 0; }
      body { overflow: hidden; background: #0e0e10; color: #ddd; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
      #info { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,.45); padding: 8px 10px; border-radius: 6px; font-size: 12px; line-height: 1.4; }
      a { color: #8ab4ff; text-decoration: none; }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="info">
      <div><strong>WebXR Excavator</strong>, click "Enter VR" to view in headset</div>
      <div>File expected next to this page: <code>SM_Veh_Excavator_01.fbx</code></div>
      <div>Mouse, drag to orbit, scroll to dolly, right click to pan</div>
      <div>Keys: <code>M</code> normal map, <code>B</code> bright-unlit, <code>E</code> emissive-lit</div>
    </div>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js';
      import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/loaders/FBXLoader.js';
      import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js';
      import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/XRControllerModelFactory.js';
      import { RoomEnvironment } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/environments/RoomEnvironment.js';

      let renderer, scene, camera, controls, model;

      init();
      animate();

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0e0e10);

        // Default camera, will be replaced by embedded camera if found
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000);
        camera.position.set(4, 2, 6);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.debug.checkShaderErrors = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local-floor');
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const pmrem = new THREE.PMREMGenerator(renderer);
        const envTex = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
        scene.environment = envTex;

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);

        // Lights
        const hemi = new THREE.HemisphereLight(0xffffff, 0x121212, 1.0);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 1.25);
        dir.position.set(5, 10, 7);
        dir.castShadow = true;
        dir.shadow.mapSize.set(2048, 2048);
        dir.shadow.camera.near = 0.1;
        dir.shadow.camera.far = 50;
        scene.add(dir);

        const ambient = new THREE.AmbientLight(0xffffff, 0.35);
        scene.add(ambient);

        // Ground
        // const ground = new THREE.Mesh(
        //   new THREE.CircleGeometry(20, 64),
        //   new THREE.MeshStandardMaterial({ color: 0x22252a, roughness: 1 })
        // );
        // ground.rotation.x = -Math.PI * 0.5;
        // ground.receiveShadow = true;
        // scene.add(ground);

        // Floor
        const floor = new THREE.Mesh(
          new THREE.PlaneGeometry(100, 100),
          new THREE.MeshStandardMaterial({ color: 0x22252a, roughness: 1, metalness: 0 })
        );
        floor.rotation.x = -Math.PI * 0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // Debug helpers
        const grid = new THREE.GridHelper(40, 40, 0x888888, 0x444444);
        scene.add(grid);

        const testCube = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshStandardMaterial({ color: 0x66ccff })
        );
        testCube.position.set(0, 0.25, 0);
        scene.add(testCube);

        // Load FBX model from same folder
        const loader = new FBXLoader();
        loader.load('./SM_Veh_Excavator_01.fbx', (fbx) => {
          model = fbx;
          model.traverse((obj)=>{ if (obj.isMesh && obj.material){ obj.material.side = THREE.FrontSide; }});
          model.traverse((obj) => { if (obj.isMesh) { obj.castShadow = true; obj.receiveShadow = true; } });
          scene.add(model);

          // Normalize model transform, scale to a comfortable size and sit on floor
          const box = new THREE.Box3().setFromObject(model);
          const sizeVec = box.getSize(new THREE.Vector3());
          let maxDim = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
          if (!isFinite(maxDim) || maxDim === 0) maxDim = 1;
          const targetSize = 6; // meters-ish
          let scale = 1;
          if (maxDim > targetSize * 2) scale = targetSize / maxDim;
          if (maxDim < 1) scale = targetSize / Math.max(1, maxDim);
          model.scale.multiplyScalar(scale);

          // Recompute box after scaling and place on floor
          const box2 = new THREE.Box3().setFromObject(model);
          const center2 = box2.getCenter(new THREE.Vector3());
          const yMin = box2.min.y;
          model.position.y += -yMin; // sit on floor at y=0
          model.position.x += -center2.x;
          model.position.z += -center2.z;

          // Update controls target to the model center
          const box3 = new THREE.Box3().setFromObject(model);
          const center3 = box3.getCenter(new THREE.Vector3());
          controls.target.copy(center3);

          // Try to use an embedded camera if present
          let embeddedCamera = null;
          model.traverse((obj) => { if (obj.isCamera && !embeddedCamera) embeddedCamera = obj; });

          if (embeddedCamera) {
            // Re-parent to scene to ensure correct world transform
            THREE.SceneUtils && console.warn('SceneUtils is not used here');
            embeddedCamera.updateWorldMatrix(true, true);
            // Clone to decouple from model hierarchy
            const camClone = embeddedCamera.clone();
            camClone.projectionMatrix.copy(embeddedCamera.projectionMatrix);
            camClone.position.setFromMatrixPosition(embeddedCamera.matrixWorld);
            camClone.quaternion.setFromRotationMatrix(embeddedCamera.matrixWorld);
            camClone.updateMatrixWorld(true);
            camera = camClone;
            scene.add(camera);
            controls.object = camera;
          } else {
            // If we are still on the default camera, re-frame it
            const size = box3.getSize(new THREE.Vector3()).length();
            const fitHeightDistance = size / (2 * Math.atan((Math.PI * camera.fov) / 360));
            const fitWidthDistance = fitHeightDistance / camera.aspect;
            const distance = Math.max(fitHeightDistance, fitWidthDistance);
            const dirVec = new THREE.Vector3(1, 0.6, 1).normalize();
            camera.position.copy(center3).add(dirVec.multiplyScalar(distance * 1.3));
            camera.near = Math.max(0.01, size / 200);
            camera.far = Math.max(50, size * 10);
            camera.updateProjectionMatrix();
          }
        }, (xhr) => {
          // Progress, optional
        }, (err) => {
          console.error('FBX load error:', err);
          const msg = document.createElement('div');
          msg.textContent = 'Could not load SM_Veh_Excavator_01.fbx (check filename, same folder, and that you are using a local web server).';
          msg.style.position = 'absolute';
          msg.style.bottom = '10px';
          msg.style.left = '10px';
          msg.style.background = 'rgba(0,0,0,.6)';
          msg.style.padding = '8px 10px';
          msg.style.borderRadius = '6px';
          document.body.appendChild(msg);
        });

        // Simple XR controllers, good for pointing and scale reference
        const controller1 = renderer.xr.getController(0);
        scene.add(controller1);
        const controller2 = renderer.xr.getController(1);
        scene.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();
        const grip1 = renderer.xr.getControllerGrip(0);
        grip1.add(controllerModelFactory.createControllerModel(grip1));
        scene.add(grip1);
        const grip2 = renderer.xr.getControllerGrip(1);
        grip2.add(controllerModelFactory.createControllerModel(grip2));
        scene.add(grip2);

        window.addEventListener('resize', onWindowResize);
      }

      function onWindowResize() {
        if (!camera) return;
        if (camera.isPerspectiveCamera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
        }
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render() {
        if (controls) {
          controls.update();
          if (camera && camera.lookAt && controls.target) {
            camera.lookAt(controls.target);
          }
        }
        renderer.render(scene, camera);
      }

      // Debug: press "m" to toggle normal material on the model
      let useNormalMat = false;
      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'm' && model) {
          useNormalMat = !useNormalMat;
          model.traverse((obj) => {
            if (obj.isMesh) {
              if (useNormalMat) {
                obj.userData._origMat = obj.material;
                obj.material = new THREE.MeshNormalMaterial();
              } else if (obj.userData._origMat) {
                obj.material = obj.userData._origMat;
                delete obj.userData._origMat;
              }
              obj.material.needsUpdate = true;
            }
          });
        }
      });

      // Debug: press "b" to toggle BRIGHT UNLIT material (MeshBasicMaterial)
      let useBasicBright = false;
      function setBasicBrightMaterial(root, enable){
        root.traverse((obj)=>{
          if (obj.isMesh){
            if (enable){
              if (!obj.userData._origMat_basic) obj.userData._origMat_basic = obj.material;
              obj.material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            } else if (obj.userData._origMat_basic){
              obj.material = obj.userData._origMat_basic; delete obj.userData._origMat_basic;
            }
            obj.material.needsUpdate = true;
          }
        });
      }

      // Debug: press "e" to toggle EMISSIVE LIT material (MeshStandardMaterial with emissive)
      let useEmissiveLit = false;
      function setEmissiveMaterial(root, enable){
        root.traverse((obj)=>{
          if (obj.isMesh){
            if (enable){
              if (!obj.userData._origMat_emissive) obj.userData._origMat_emissive = obj.material;
              obj.material = new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                emissive: 0x333333,
                emissiveIntensity: 1.0,
                roughness: 0.6,
                metalness: 0.0
              });
            } else if (obj.userData._origMat_emissive){
              obj.material = obj.userData._origMat_emissive; delete obj.userData._origMat_emissive;
            }
            obj.material.needsUpdate = true;
          }
        });
      }

      window.addEventListener('keydown', (e) => {
        if (!model) return;
        const k = e.key.toLowerCase();
        if (k === 'b') {
          useBasicBright = !useBasicBright;
          // disable emissive if enabling basic, to avoid conflicts
          if (useBasicBright && useEmissiveLit) { useEmissiveLit = false; setEmissiveMaterial(model, false); }
          setBasicBrightMaterial(model, useBasicBright);
        }
        if (k === 'e') {
          useEmissiveLit = !useEmissiveLit;
          // disable basic if enabling emissive
          if (useEmissiveLit && useBasicBright) { useBasicBright = false; setBasicBrightMaterial(model, false); }
          setEmissiveMaterial(model, useEmissiveLit);
        }
      });
    </script>
  </body>
</html>